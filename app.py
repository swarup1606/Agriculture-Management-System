import streamlit as st
import os
import pandas as pd
import requests
from gtts import gTTS  # For Text-to-Speech
import speech_recognition as sr  # For Speech-to-Text
import os
import tempfile
from PIL import Image, UnidentifiedImageError
from io import BytesIO
from streamlit_extras.colored_header import colored_header
from streamlit_extras.metric_cards import style_metric_cards
from streamlit_lottie import st_lottie
from sklearn.ensemble import RandomForestRegressor, RandomForestClassifier
from sklearn.metrics import accuracy_score
from sklearn.model_selection import train_test_split
import joblib
from dotenv import load_dotenv
import google.generativeai as genai
from disease import analyze_plant_disease
import ee
import geemap
import folium
from streamlit_folium import folium_static
from datetime import datetime, timedelta

# -------------------- RAG Imports --------------------
from langchain_community.document_loaders import PDFPlumberLoader
from langchain_text_splitters import RecursiveCharacterTextSplitter
from langchain_core.vectorstores import InMemoryVectorStore
from langchain_ollama import OllamaEmbeddings  # Added missing import
from langchain_core.prompts import ChatPromptTemplate
from langchain_ollama.llms import OllamaLLM
# -------------------- Multilingual Setup --------------------
translations = {
    "en": {
        "rag_description": "Upload up to 4 agricultural research PDFs (e.g., crop guides, soil manuals)",
        "pdf_upload_label": "Upload Research PDFs (Max 4)",
        "processing_pdf": "Processing PDF {current}/{total}...",
        "max_files_warning": "Maximum 4 files allowed",
        "sidebar_title": "üåæ AgroBloom AI",
        "home_title": "üå± AgroBloom AI",
        "welcome_message": "Welcome to AgroBloom AI - Your intelligent farming companion! Harness the power of artificial intelligence to optimize your agricultural operations, increase crop yield, and make data-driven decisions for sustainable farming.",
        "weather_report": "Weather Report for",
        "farming_advisory": "Farming Advisory",
        "soil_moisture_map": "Soil Moisture Map",
        "current_conditions": "Current Conditions",
        "select_language": "Select Language",
        "home": "Home",
        "weather_forecasting": "Weather Forecasting",
        "irrigation_management": "Irrigation Management",
        "soil_health_analysis": "Soil Health Analysis",
        
        "disease_detection": "Disease Detection",
        "ai_assistant": "AI Assistant",
        "navigation": "Navigation",
        "smart_weather_insights": "Smart Weather Insights",
        "smart_weather_desc": "Get real-time weather data and farming advice based on your location.",
        "ai_irrigation_system": "AI-Powered Irrigation System",
        "ai_irrigation_desc": "Optimize water usage with predictive analytics and real-time soil moisture data.",
        "soil_health_dashboard": "Soil Health Dashboard",
        "soil_health_desc": "Analyze soil parameters and get actionable insights for improvement.",
        "disease_detection_title": "Plant Disease Detection",
        "disease_detection_desc": "Upload plant images to detect diseases and receive treatment recommendations.",
        "join_revolution": "Join the Agricultural Revolution",
        "start_journey": "Start your journey towards smarter farming today!",
        "enter_location": "Enter Location",
        "get_weather_analysis": "Get Weather Analysis",
        "fetching_weather_data": "Fetching weather data...",
        "temperature": "Temperature",
        "humidity": "Humidity",
        "precipitation": "Precipitation",
        "wind_speed": "Wind Speed",
        "frost_alert": "Frost alert: Protect sensitive crops from low temperatures.",
        "cool_weather": "Cool weather: Suitable for most crops with proper care.",
        "optimal_conditions": "Optimal conditions: Ideal weather for crop growth.",
        "heat_stress": "Heat stress: Ensure proper irrigation to mitigate high temperatures.",
        "failed_to_retrieve_weather_data": "Failed to retrieve weather data. Please check the location and try again.",
        "smart_irrigation_system": "Smart Irrigation System",
        "irrigation_desc": "Use AI to manage irrigation efficiently.",
        "field_parameters": "Field Parameters",
        "select_region_category": "Select Region Category",
        "select_location": "Select Location",
        "use_custom_location": "Use Custom Location",
        "enter_custom_location": "Enter Custom Location",
        "crop_type": "Crop Type",
        "optimal_moisture_tip": "Optimal moisture varies by crop type.",
        "calculate_irrigation": "Calculate Irrigation Needs",
        "analyzing_field_conditions": "Analyzing field conditions...",
        "irrigation_plan": "Irrigation Plan",
        "irrigation_analysis": "Irrigation Analysis",
        "soil_moisture": "Soil Moisture",
        "soil_moisture_level": "Soil Moisture Level",
        "crop_specific_analysis": "Crop-Specific Analysis",
        "optimal_soil_moisture_range": "Optimal Soil Moisture Range",
        "below_optimal": "Soil moisture is below optimal for {crop_type}. Consider irrigating.",
        "above_optimal": "Soil moisture is above optimal for {crop_type}. Reduce irrigation.",
        "within_optimal": "Soil moisture is within optimal range for {crop_type}.",
        "water_conservation_impact": "Water Conservation Impact",
        "monthly_savings": "Monthly Savings",
        "water_saved": "Water Saved",
        "cost_reduction": "Cost Reduction",
        "environmental_impact": "Environmental Impact",
        "carbon_footprint_reduction": "Carbon Footprint Reduction",
        "sustainability_score": "Sustainability Score",
        "how_to_use": "How to Use",
        "input_soil_test_results": "Input your soil test results below.",
        "click_analyze_soil_health": "Click 'Analyze Soil Health' to process the data.",
        "receive_recommendations": "Receive tailored recommendations for soil improvement.",
        "soil_parameters": "Soil Parameters",
        "soil_ph": "Soil pH",
        "nitrogen": "Nitrogen (kg/ha)",
        "phosphorus": "Phosphorus (kg/ha)",
        "potassium": "Potassium (kg/ha)",
        "organic_matter": "Organic Matter (%)",
        "analyze_soil_health": "Analyze Soil Health",
        "analyzing_soil_composition": "Analyzing soil composition...",
        "analysis_results": "Analysis Results",
       
        "apply_organic_compost": "Apply organic compost to improve organic matter.",
        "ideal_soil_ph": "Adjust pH to 6.0-7.5 if needed.",
        "ideal_nitrogen": "Maintain nitrogen levels between 20-50 kg/ha.",
        "ideal_phosphorus": "Maintain phosphorus levels between 15-40 kg/ha.",
        "ideal_potassium": "Maintain potassium levels between 15-40 kg/ha.",
        "retest_soil": "Retest soil after 3 months.",
        "smart_crop_advisor": "Smart Crop Advisor",
        "crop_advisor_desc": "Get crop recommendations based on soil conditions.",
        "field_conditions": "Field Conditions",
        
        "analyzing_optimal_crops": "Analyzing optimal crops...",
        
        "expected_yield": "Expected Yield",
        "best_season": "Best Season",
        "upload_plant_image_desc": "Upload an image of your plant for analysis.",
        "click_analyze_disease": "Click 'Analyze Disease' to start the process.",
        "receive_disease_recommendations": "Receive disease detection results and recommendations.",
        "upload_plant_image": "Upload Plant Image",
        "uploaded_image": "Uploaded Image",
        "analyze_disease": "Analyze Disease",
        "analyzing_disease": "Analyzing disease...",
        "disease_detection_results": "Disease Detection Results",
        "consult_expert": "Consult a local agricultural expert for confirmation.",
        "apply_treatment": "Apply recommended treatment as soon as possible.",
        "monitor_health": "Monitor plant health over the next few weeks.",
        "invalid_image_error": "Invalid image file. Please upload a valid JPG or PNG image.",
        "error_occurred": "An error occurred",
        "ai_assistant": "AI Agriculture Assistant",
        "upload_research_pdf": "Upload Research PDF",
        "rag_upload_help": "Upload agricultural research papers or guides",
        "doc_processed_success": "Document processed successfully! Ask questions below.",
        "ask_agriculture_question": "Ask about agricultural practices...",
        "processing_error": "Document processing failed",
        "response_error": "Failed to generate response",
        "train_crop_model": "Train Crop Recommendation Model"
    },
    "hi": {
        "sidebar_title": "üåæ ‡§è‡§ó‡•ç‡§∞‡•ã‡§¨‡•ç‡§≤‡•Ç‡§Æ ‡§è‡§Ü‡§à",
        "home_title": "üå± ‡§è‡§ó‡•ç‡§∞‡•ã‡§¨‡•ç‡§≤‡•Ç‡§Æ ‡§è‡§Ü‡§à",
        "welcome_message": "‡§è‡§ó‡•ç‡§∞‡•ã‡§¨‡•ç‡§≤‡•Ç‡§Æ ‡§è‡§Ü‡§à ‡§Æ‡•á‡§Ç ‡§Ü‡§™‡§ï‡§æ ‡§∏‡•ç‡§µ‡§æ‡§ó‡§§ ‡§π‡•à - ‡§Ü‡§™‡§ï‡§æ ‡§¨‡•Å‡§¶‡•ç‡§ß‡§ø‡§Æ‡§æ‡§® ‡§ï‡•É‡§∑‡§ø ‡§∏‡§æ‡§•‡•Ä! ‡§ï‡•É‡§§‡•ç‡§∞‡§ø‡§Æ ‡§¨‡•Å‡§¶‡•ç‡§ß‡§ø‡§Æ‡§§‡•ç‡§§‡§æ ‡§ï‡•Ä ‡§∂‡§ï‡•ç‡§§‡§ø ‡§ï‡§æ ‡§â‡§™‡§Ø‡•ã‡§ó ‡§ï‡§∞‡•á‡§Ç ‡§Ö‡§™‡§®‡•Ä ‡§ï‡•É‡§∑‡§ø ‡§ó‡§§‡§ø‡§µ‡§ø‡§ß‡§ø‡§Ø‡•ã‡§Ç ‡§ï‡•ã ‡§Ö‡§®‡•Å‡§ï‡•Ç‡§≤‡§ø‡§§ ‡§ï‡§∞‡§®‡•á, ‡§´‡§∏‡§≤ ‡§ï‡•Ä ‡§â‡§™‡§ú ‡§¨‡§¢‡§º‡§æ‡§®‡•á ‡§î‡§∞ ‡§∏‡§§‡§§ ‡§ï‡•É‡§∑‡§ø ‡§ï‡•á ‡§≤‡§ø‡§è ‡§°‡•á‡§ü‡§æ-‡§∏‡§Ç‡§ö‡§æ‡§≤‡§ø‡§§ ‡§®‡§ø‡§∞‡•ç‡§£‡§Ø ‡§≤‡•á‡§®‡•á ‡§Æ‡•á‡§Ç‡•§",
        "weather_report": "‡§ï‡•á ‡§≤‡§ø‡§è ‡§Æ‡•å‡§∏‡§Æ ‡§∞‡§ø‡§™‡•ã‡§∞‡•ç‡§ü",
        "farming_advisory": "‡§ï‡•É‡§∑‡§ø ‡§∏‡§≤‡§æ‡§π",
        "soil_moisture_map": "‡§Æ‡§ø‡§ü‡•ç‡§ü‡•Ä ‡§ï‡•Ä ‡§®‡§Æ‡•Ä ‡§ï‡§æ ‡§Æ‡§æ‡§®‡§ö‡§ø‡§§‡•ç‡§∞",
        "current_conditions": "‡§µ‡§∞‡•ç‡§§‡§Æ‡§æ‡§® ‡§∏‡•ç‡§•‡§ø‡§§‡§ø‡§Ø‡§æ‡§Ç",
        "select_language": "‡§≠‡§æ‡§∑‡§æ ‡§ö‡•Å‡§®‡•á‡§Ç",
        "home": "‡§π‡•ã‡§Æ",
        "weather_forecasting": "‡§Æ‡•å‡§∏‡§Æ ‡§™‡•Ç‡§∞‡•ç‡§µ‡§æ‡§®‡•Å‡§Æ‡§æ‡§®",
        "irrigation_management": "‡§∏‡§ø‡§Ç‡§ö‡§æ‡§à ‡§™‡•ç‡§∞‡§¨‡§Ç‡§ß‡§®",
        "soil_health_analysis": "‡§Æ‡§ø‡§ü‡•ç‡§ü‡•Ä ‡§∏‡•ç‡§µ‡§æ‡§∏‡•ç‡§•‡•ç‡§Ø ‡§µ‡§ø‡§∂‡•ç‡§≤‡•á‡§∑‡§£",
    
        "disease_detection": "‡§∞‡•ã‡§ó ‡§™‡§π‡§ö‡§æ‡§®",
        "ai_assistant": "‡§è‡§Ü‡§à ‡§∏‡§π‡§æ‡§Ø‡§ï",
        "navigation": "‡§®‡•á‡§µ‡§ø‡§ó‡•á‡§∂‡§®",
        "smart_weather_insights": "‡§∏‡•ç‡§Æ‡§æ‡§∞‡•ç‡§ü ‡§Æ‡•å‡§∏‡§Æ ‡§Ö‡§Ç‡§§‡§∞‡•ç‡§¶‡•É‡§∑‡•ç‡§ü‡§ø",
        "smart_weather_desc": "‡§Ö‡§™‡§®‡•á ‡§∏‡•ç‡§•‡§æ‡§® ‡§ï‡•á ‡§Ü‡§ß‡§æ‡§∞ ‡§™‡§∞ ‡§µ‡§æ‡§∏‡•ç‡§§‡§µ‡§ø‡§ï ‡§∏‡§Æ‡§Ø ‡§Æ‡•å‡§∏‡§Æ ‡§°‡•á‡§ü‡§æ ‡§î‡§∞ ‡§ï‡•É‡§∑‡§ø ‡§∏‡§≤‡§æ‡§π ‡§™‡•ç‡§∞‡§æ‡§™‡•ç‡§§ ‡§ï‡§∞‡•á‡§Ç‡•§",
        "ai_irrigation_system": "‡§è‡§Ü‡§à-‡§∏‡§Ç‡§ö‡§æ‡§≤‡§ø‡§§ ‡§∏‡§ø‡§Ç‡§ö‡§æ‡§à ‡§™‡•ç‡§∞‡§£‡§æ‡§≤‡•Ä",
        "ai_irrigation_desc": "‡§≠‡§µ‡§ø‡§∑‡•ç‡§Ø‡§µ‡§æ‡§£‡•Ä ‡§µ‡§ø‡§∂‡•ç‡§≤‡•á‡§∑‡§£ ‡§î‡§∞ ‡§µ‡§æ‡§∏‡•ç‡§§‡§µ‡§ø‡§ï ‡§∏‡§Æ‡§Ø ‡§Æ‡§ø‡§ü‡•ç‡§ü‡•Ä ‡§®‡§Æ‡•Ä ‡§°‡•á‡§ü‡§æ ‡§ï‡•á ‡§∏‡§æ‡§• ‡§ú‡§≤ ‡§â‡§™‡§Ø‡•ã‡§ó ‡§ï‡•ã ‡§Ö‡§®‡•Å‡§ï‡•Ç‡§≤‡§ø‡§§ ‡§ï‡§∞‡•á‡§Ç‡•§",
        "soil_health_dashboard": "‡§Æ‡§ø‡§ü‡•ç‡§ü‡•Ä ‡§∏‡•ç‡§µ‡§æ‡§∏‡•ç‡§•‡•ç‡§Ø ‡§°‡•à‡§∂‡§¨‡•ã‡§∞‡•ç‡§°",
        "soil_health_desc": "‡§Æ‡§ø‡§ü‡•ç‡§ü‡•Ä ‡§ï‡•á ‡§Æ‡§æ‡§™‡§¶‡§Ç‡§°‡•ã‡§Ç ‡§ï‡§æ ‡§µ‡§ø‡§∂‡•ç‡§≤‡•á‡§∑‡§£ ‡§ï‡§∞‡•á‡§Ç ‡§î‡§∞ ‡§∏‡•Å‡§ß‡§æ‡§∞ ‡§ï‡•á ‡§≤‡§ø‡§è ‡§â‡§™‡§Ø‡•ã‡§ó‡•Ä ‡§ú‡§æ‡§®‡§ï‡§æ‡§∞‡•Ä ‡§™‡•ç‡§∞‡§æ‡§™‡•ç‡§§ ‡§ï‡§∞‡•á‡§Ç‡•§",
        "disease_detection_title": "‡§™‡•å‡§ß‡•á ‡§∞‡•ã‡§ó ‡§™‡§π‡§ö‡§æ‡§®",
        "disease_detection_desc": "‡§™‡•å‡§ß‡•ã‡§Ç ‡§ï‡•Ä ‡§õ‡§µ‡§ø‡§Ø‡§æ‡§Ç ‡§Ö‡§™‡§≤‡•ã‡§° ‡§ï‡§∞‡•á‡§Ç ‡§∞‡•ã‡§ó‡•ã‡§Ç ‡§ï‡§æ ‡§™‡§§‡§æ ‡§≤‡§ó‡§æ‡§®‡•á ‡§î‡§∞ ‡§â‡§™‡§ö‡§æ‡§∞ ‡§∏‡§ø‡§´‡§æ‡§∞‡§ø‡§∂‡•á‡§Ç ‡§™‡•ç‡§∞‡§æ‡§™‡•ç‡§§ ‡§ï‡§∞‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è‡•§",
        "join_revolution": "‡§ï‡•É‡§∑‡§ø ‡§ï‡•ç‡§∞‡§æ‡§Ç‡§§‡§ø ‡§Æ‡•á‡§Ç ‡§∂‡§æ‡§Æ‡§ø‡§≤ ‡§π‡•ã‡§Ç",
        "start_journey": "‡§Ü‡§ú ‡§π‡•Ä ‡§∏‡•ç‡§Æ‡§æ‡§∞‡•ç‡§ü ‡§ñ‡•á‡§§‡•Ä ‡§ï‡•Ä ‡§ì‡§∞ ‡§Ö‡§™‡§®‡•Ä ‡§Ø‡§æ‡§§‡•ç‡§∞‡§æ ‡§∂‡•Å‡§∞‡•Ç ‡§ï‡§∞‡•á‡§Ç!",
        "enter_location": "‡§∏‡•ç‡§•‡§æ‡§® ‡§¶‡§∞‡•ç‡§ú ‡§ï‡§∞‡•á‡§Ç",
        "get_weather_analysis": "‡§Æ‡•å‡§∏‡§Æ ‡§µ‡§ø‡§∂‡•ç‡§≤‡•á‡§∑‡§£ ‡§™‡•ç‡§∞‡§æ‡§™‡•ç‡§§ ‡§ï‡§∞‡•á‡§Ç",
        "fetching_weather_data": "‡§Æ‡•å‡§∏‡§Æ ‡§°‡•á‡§ü‡§æ ‡§™‡•ç‡§∞‡§æ‡§™‡•ç‡§§ ‡§ï‡§∞ ‡§∞‡§π‡§æ ‡§π‡•à...",
        "temperature": "‡§§‡§æ‡§™‡§Æ‡§æ‡§®",
        "humidity": "‡§Ü‡§∞‡•ç‡§¶‡•ç‡§∞‡§§‡§æ",
        "precipitation": "‡§µ‡§∞‡•ç‡§∑‡§æ",
        "wind_speed": "‡§π‡§µ‡§æ ‡§ï‡•Ä ‡§ó‡§§‡§ø",
        "frost_alert": "‡§™‡§æ‡§≤‡§æ ‡§ö‡•á‡§§‡§æ‡§µ‡§®‡•Ä: ‡§∏‡§Ç‡§µ‡•á‡§¶‡§®‡§∂‡•Ä‡§≤ ‡§´‡§∏‡§≤‡•ã‡§Ç ‡§ï‡•ã ‡§ï‡§Æ ‡§§‡§æ‡§™‡§Æ‡§æ‡§® ‡§∏‡•á ‡§¨‡§ö‡§æ‡§è‡§Ç‡•§",
        "cool_weather": "‡§†‡§Ç‡§°‡§æ ‡§Æ‡•å‡§∏‡§Æ: ‡§â‡§ö‡§ø‡§§ ‡§¶‡•á‡§ñ‡§≠‡§æ‡§≤ ‡§ï‡•á ‡§∏‡§æ‡§• ‡§Ö‡§ß‡§ø‡§ï‡§æ‡§Ç‡§∂ ‡§´‡§∏‡§≤‡•ã‡§Ç ‡§ï‡•á ‡§≤‡§ø‡§è ‡§â‡§™‡§Ø‡•Å‡§ï‡•ç‡§§‡•§",
        "optimal_conditions": "‡§á‡§∑‡•ç‡§ü‡§§‡§Æ ‡§∏‡•ç‡§•‡§ø‡§§‡§ø‡§Ø‡§æ‡§Ç: ‡§´‡§∏‡§≤ ‡§µ‡•É‡§¶‡•ç‡§ß‡§ø ‡§ï‡•á ‡§≤‡§ø‡§è ‡§Ü‡§¶‡§∞‡•ç‡§∂ ‡§Æ‡•å‡§∏‡§Æ‡•§",
        "heat_stress": "‡§ó‡§∞‡•ç‡§Æ‡•Ä ‡§§‡§®‡§æ‡§µ: ‡§â‡§ö‡•ç‡§ö ‡§§‡§æ‡§™‡§Æ‡§æ‡§® ‡§ï‡•ã ‡§ï‡§Æ ‡§ï‡§∞‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è ‡§â‡§ö‡§ø‡§§ ‡§∏‡§ø‡§Ç‡§ö‡§æ‡§à ‡§∏‡•Å‡§®‡§ø‡§∂‡•ç‡§ö‡§ø‡§§ ‡§ï‡§∞‡•á‡§Ç‡•§",
        "failed_to_retrieve_weather_data": "‡§Æ‡•å‡§∏‡§Æ ‡§°‡•á‡§ü‡§æ ‡§™‡•ç‡§∞‡§æ‡§™‡•ç‡§§ ‡§ï‡§∞‡§®‡•á ‡§Æ‡•á‡§Ç ‡§µ‡§ø‡§´‡§≤‡•§ ‡§ï‡•É‡§™‡§Ø‡§æ ‡§∏‡•ç‡§•‡§æ‡§® ‡§ú‡§æ‡§Ç‡§ö‡•á‡§Ç ‡§î‡§∞ ‡§™‡•Å‡§®‡§É ‡§™‡•ç‡§∞‡§Ø‡§æ‡§∏ ‡§ï‡§∞‡•á‡§Ç‡•§",
        "smart_irrigation_system": "‡§∏‡•ç‡§Æ‡§æ‡§∞‡•ç‡§ü ‡§∏‡§ø‡§Ç‡§ö‡§æ‡§à ‡§™‡•ç‡§∞‡§£‡§æ‡§≤‡•Ä",
        "irrigation_desc": "‡§∏‡§ø‡§Ç‡§ö‡§æ‡§à ‡§ï‡•ã ‡§ï‡•Å‡§∂‡§≤‡§§‡§æ‡§™‡•Ç‡§∞‡•ç‡§µ‡§ï ‡§™‡•ç‡§∞‡§¨‡§Ç‡§ß‡§ø‡§§ ‡§ï‡§∞‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è ‡§è‡§Ü‡§à ‡§ï‡§æ ‡§â‡§™‡§Ø‡•ã‡§ó ‡§ï‡§∞‡•á‡§Ç‡•§",
        "field_parameters": "‡§ñ‡•á‡§§ ‡§ï‡•á ‡§Æ‡§æ‡§™‡§¶‡§Ç‡§°",
        "select_region_category": "‡§ï‡•ç‡§∑‡•á‡§§‡•ç‡§∞ ‡§∂‡•ç‡§∞‡•á‡§£‡•Ä ‡§ö‡•Å‡§®‡•á‡§Ç",
        "select_location": "‡§∏‡•ç‡§•‡§æ‡§® ‡§ö‡•Å‡§®‡•á‡§Ç",
        "use_custom_location": "‡§ï‡§∏‡•ç‡§ü‡§Æ ‡§∏‡•ç‡§•‡§æ‡§® ‡§ï‡§æ ‡§â‡§™‡§Ø‡•ã‡§ó ‡§ï‡§∞‡•á‡§Ç",
        "enter_custom_location": "‡§ï‡§∏‡•ç‡§ü‡§Æ ‡§∏‡•ç‡§•‡§æ‡§® ‡§¶‡§∞‡•ç‡§ú ‡§ï‡§∞‡•á‡§Ç",
        "crop_type": "‡§´‡§∏‡§≤ ‡§™‡•ç‡§∞‡§ï‡§æ‡§∞",
        "optimal_moisture_tip": "‡§á‡§∑‡•ç‡§ü‡§§‡§Æ ‡§®‡§Æ‡•Ä ‡§´‡§∏‡§≤ ‡§™‡•ç‡§∞‡§ï‡§æ‡§∞ ‡§ï‡•á ‡§Ö‡§®‡•Å‡§∏‡§æ‡§∞ ‡§≠‡§ø‡§®‡•ç‡§® ‡§π‡•ã‡§§‡•Ä ‡§π‡•à‡•§",
        "calculate_irrigation": "‡§∏‡§ø‡§Ç‡§ö‡§æ‡§à ‡§ï‡•Ä ‡§Ü‡§µ‡§∂‡•ç‡§Ø‡§ï‡§§‡§æ ‡§ï‡•Ä ‡§ó‡§£‡§®‡§æ ‡§ï‡§∞‡•á‡§Ç",
        "analyzing_field_conditions": "‡§ñ‡•á‡§§ ‡§ï‡•Ä ‡§∏‡•ç‡§•‡§ø‡§§‡§ø‡§Ø‡•ã‡§Ç ‡§ï‡§æ ‡§µ‡§ø‡§∂‡•ç‡§≤‡•á‡§∑‡§£ ‡§ï‡§∞ ‡§∞‡§π‡§æ ‡§π‡•à...",
        "irrigation_plan": "‡§∏‡§ø‡§Ç‡§ö‡§æ‡§à ‡§Ø‡•ã‡§ú‡§®‡§æ",
        "irrigation_analysis": "‡§∏‡§ø‡§Ç‡§ö‡§æ‡§à ‡§µ‡§ø‡§∂‡•ç‡§≤‡•á‡§∑‡§£",
        "soil_moisture": "‡§Æ‡§ø‡§ü‡•ç‡§ü‡•Ä ‡§ï‡•Ä ‡§®‡§Æ‡•Ä",
        "soil_moisture_level": "‡§Æ‡§ø‡§ü‡•ç‡§ü‡•Ä ‡§ï‡•Ä ‡§®‡§Æ‡•Ä ‡§∏‡•ç‡§§‡§∞",
        "crop_specific_analysis": "‡§´‡§∏‡§≤-‡§µ‡§ø‡§∂‡§ø‡§∑‡•ç‡§ü ‡§µ‡§ø‡§∂‡•ç‡§≤‡•á‡§∑‡§£",
        "optimal_soil_moisture_range": "‡§á‡§∑‡•ç‡§ü‡§§‡§Æ ‡§Æ‡§ø‡§ü‡•ç‡§ü‡•Ä ‡§®‡§Æ‡•Ä ‡§∞‡•á‡§Ç‡§ú",
        "below_optimal": "{crop_type} ‡§ï‡•á ‡§≤‡§ø‡§è ‡§Æ‡§ø‡§ü‡•ç‡§ü‡•Ä ‡§ï‡•Ä ‡§®‡§Æ‡•Ä ‡§á‡§∑‡•ç‡§ü‡§§‡§Æ ‡§∏‡•á ‡§ï‡§Æ ‡§π‡•à‡•§ ‡§∏‡§ø‡§Ç‡§ö‡§æ‡§à ‡§™‡§∞ ‡§µ‡§ø‡§ö‡§æ‡§∞ ‡§ï‡§∞‡•á‡§Ç‡•§",
        "above_optimal": "{crop_type} ‡§ï‡•á ‡§≤‡§ø‡§è ‡§Æ‡§ø‡§ü‡•ç‡§ü‡•Ä ‡§ï‡•Ä ‡§®‡§Æ‡•Ä ‡§á‡§∑‡•ç‡§ü‡§§‡§Æ ‡§∏‡•á ‡§Ö‡§ß‡§ø‡§ï ‡§π‡•à‡•§ ‡§∏‡§ø‡§Ç‡§ö‡§æ‡§à ‡§ï‡§Æ ‡§ï‡§∞‡•á‡§Ç‡•§",
        "within_optimal": "{crop_type} ‡§ï‡•á ‡§≤‡§ø‡§è ‡§Æ‡§ø‡§ü‡•ç‡§ü‡•Ä ‡§ï‡•Ä ‡§®‡§Æ‡•Ä ‡§á‡§∑‡•ç‡§ü‡§§‡§Æ ‡§∞‡•á‡§Ç‡§ú ‡§Æ‡•á‡§Ç ‡§π‡•à‡•§",
        "water_conservation_impact": "‡§ú‡§≤ ‡§∏‡§Ç‡§∞‡§ï‡•ç‡§∑‡§£ ‡§™‡•ç‡§∞‡§≠‡§æ‡§µ",
        "monthly_savings": "‡§Æ‡§æ‡§∏‡§ø‡§ï ‡§¨‡§ö‡§§",
        "water_saved": "‡§™‡§æ‡§®‡•Ä ‡§¨‡§ö‡§æ‡§Ø‡§æ ‡§ó‡§Ø‡§æ",
        "cost_reduction": "‡§≤‡§æ‡§ó‡§§ ‡§Æ‡•á‡§Ç ‡§ï‡§Æ‡•Ä",
        "environmental_impact": "‡§™‡§∞‡•ç‡§Ø‡§æ‡§µ‡§∞‡§£‡•Ä‡§Ø ‡§™‡•ç‡§∞‡§≠‡§æ‡§µ",
        "carbon_footprint_reduction": "‡§ï‡§æ‡§∞‡•ç‡§¨‡§® ‡§´‡•Å‡§ü‡§™‡•ç‡§∞‡§ø‡§Ç‡§ü ‡§Æ‡•á‡§Ç ‡§ï‡§Æ‡•Ä",
        "sustainability_score": "‡§∏‡•ç‡§•‡§ø‡§∞‡§§‡§æ ‡§∏‡•ç‡§ï‡•ã‡§∞",
        "how_to_use": "‡§â‡§™‡§Ø‡•ã‡§ó ‡§ï‡•à‡§∏‡•á ‡§ï‡§∞‡•á‡§Ç",
        "input_soil_test_results": "‡§®‡•Ä‡§ö‡•á ‡§Ö‡§™‡§®‡•á ‡§Æ‡§ø‡§ü‡•ç‡§ü‡•Ä ‡§™‡§∞‡•Ä‡§ï‡•ç‡§∑‡§£ ‡§™‡§∞‡§ø‡§£‡§æ‡§Æ ‡§¶‡§∞‡•ç‡§ú ‡§ï‡§∞‡•á‡§Ç‡•§",
        "click_analyze_soil_health": "‡§°‡•á‡§ü‡§æ ‡§ï‡•ã ‡§∏‡§Ç‡§∏‡§æ‡§ß‡§ø‡§§ ‡§ï‡§∞‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è '‡§Æ‡§ø‡§ü‡•ç‡§ü‡•Ä ‡§∏‡•ç‡§µ‡§æ‡§∏‡•ç‡§•‡•ç‡§Ø ‡§µ‡§ø‡§∂‡•ç‡§≤‡•á‡§∑‡§£' ‡§™‡§∞ ‡§ï‡•ç‡§≤‡§ø‡§ï ‡§ï‡§∞‡•á‡§Ç‡•§",
        "receive_recommendations": "‡§Æ‡§ø‡§ü‡•ç‡§ü‡•Ä ‡§∏‡•Å‡§ß‡§æ‡§∞ ‡§ï‡•á ‡§≤‡§ø‡§è ‡§Ö‡§®‡•Å‡§ï‡•Ç‡§≤‡§ø‡§§ ‡§∏‡§ø‡§´‡§æ‡§∞‡§ø‡§∂‡•á‡§Ç ‡§™‡•ç‡§∞‡§æ‡§™‡•ç‡§§ ‡§ï‡§∞‡•á‡§Ç‡•§",
        "soil_parameters": "‡§Æ‡§ø‡§ü‡•ç‡§ü‡•Ä ‡§ï‡•á ‡§Æ‡§æ‡§™‡§¶‡§Ç‡§°",
        "soil_ph": "‡§Æ‡§ø‡§ü‡•ç‡§ü‡•Ä ‡§ï‡§æ ‡§™‡•Ä‡§è‡§ö",
        "nitrogen": "‡§®‡§æ‡§á‡§ü‡•ç‡§∞‡•ã‡§ú‡§® (‡§ï‡§ø‡§ó‡•ç‡§∞‡§æ/‡§π‡•á‡§ï‡•ç‡§ü‡•á‡§Ø‡§∞)",
        "phosphorus": "‡§´‡•â‡§∏‡•ç‡§´‡•ã‡§∞‡§∏ (‡§ï‡§ø‡§ó‡•ç‡§∞‡§æ/‡§π‡•á‡§ï‡•ç‡§ü‡•á‡§Ø‡§∞)",
        "potassium": "‡§™‡•ã‡§ü‡•à‡§∂‡§ø‡§Ø‡§Æ (‡§ï‡§ø‡§ó‡•ç‡§∞‡§æ/‡§π‡•á‡§ï‡•ç‡§ü‡•á‡§Ø‡§∞)",
        "organic_matter": "‡§ú‡•à‡§µ‡§ø‡§ï ‡§™‡§¶‡§æ‡§∞‡•ç‡§• (%)",
        "analyze_soil_health": "‡§Æ‡§ø‡§ü‡•ç‡§ü‡•Ä ‡§∏‡•ç‡§µ‡§æ‡§∏‡•ç‡§•‡•ç‡§Ø ‡§µ‡§ø‡§∂‡•ç‡§≤‡•á‡§∑‡§£",
        "analyzing_soil_composition": "‡§Æ‡§ø‡§ü‡•ç‡§ü‡•Ä ‡§∏‡§Ç‡§∞‡§ö‡§®‡§æ ‡§ï‡§æ ‡§µ‡§ø‡§∂‡•ç‡§≤‡•á‡§∑‡§£ ‡§ï‡§∞ ‡§∞‡§π‡§æ ‡§π‡•à...",
        "analysis_results": "‡§µ‡§ø‡§∂‡•ç‡§≤‡•á‡§∑‡§£ ‡§™‡§∞‡§ø‡§£‡§æ‡§Æ",
        "recommended_actions": "‡§Ö‡§®‡•Å‡§∂‡§Ç‡§∏‡§ø‡§§ ‡§ï‡§æ‡§∞‡•ç‡§∞‡§µ‡§æ‡§á‡§Ø‡§æ‡§Å",
        "apply_organic_compost": "‡§ú‡•à‡§µ‡§ø‡§ï ‡§ñ‡§æ‡§¶ ‡§≤‡§æ‡§ó‡•Ç ‡§ï‡§∞‡•á‡§Ç ‡§§‡§æ‡§ï‡§ø ‡§ú‡•à‡§µ‡§ø‡§ï ‡§™‡§¶‡§æ‡§∞‡•ç‡§• ‡§Æ‡•á‡§Ç ‡§∏‡•Å‡§ß‡§æ‡§∞ ‡§π‡•ã‡•§",
        "ideal_soil_ph": "‡§Ø‡§¶‡§ø ‡§Ü‡§µ‡§∂‡•ç‡§Ø‡§ï ‡§π‡•ã ‡§§‡•ã ‡§™‡•Ä‡§è‡§ö ‡§ï‡•ã 6.0-7.5 ‡§§‡§ï ‡§∏‡§Æ‡§æ‡§Ø‡•ã‡§ú‡§ø‡§§ ‡§ï‡§∞‡•á‡§Ç‡•§",
        "ideal_nitrogen": "‡§®‡§æ‡§á‡§ü‡•ç‡§∞‡•ã‡§ú‡§® ‡§∏‡•ç‡§§‡§∞ ‡§ï‡•ã 20-50 ‡§ï‡§ø‡§ó‡•ç‡§∞‡§æ/‡§π‡•á‡§ï‡•ç‡§ü‡•á‡§Ø‡§∞ ‡§ï‡•á ‡§¨‡•Ä‡§ö ‡§¨‡§®‡§æ‡§è ‡§∞‡§ñ‡•á‡§Ç‡•§",
        "ideal_phosphorus": "‡§´‡•â‡§∏‡•ç‡§´‡•ã‡§∞‡§∏ ‡§∏‡•ç‡§§‡§∞ ‡§ï‡•ã 15-40 ‡§ï‡§ø‡§ó‡•ç‡§∞‡§æ/‡§π‡•á‡§ï‡•ç‡§ü‡•á‡§Ø‡§∞ ‡§ï‡•á ‡§¨‡•Ä‡§ö ‡§¨‡§®‡§æ‡§è ‡§∞‡§ñ‡•á‡§Ç‡•§",
        "ideal_potassium": "‡§™‡•ã‡§ü‡•à‡§∂‡§ø‡§Ø‡§Æ ‡§∏‡•ç‡§§‡§∞ ‡§ï‡•ã 15-40 ‡§ï‡§ø‡§ó‡•ç‡§∞‡§æ/‡§π‡•á‡§ï‡•ç‡§ü‡•á‡§Ø‡§∞ ‡§ï‡•á ‡§¨‡•Ä‡§ö ‡§∞‡§ñ‡•á‡§Ç‡•§",
        "retest_soil": "3 ‡§Æ‡§π‡•Ä‡§®‡•á ‡§¨‡§æ‡§¶ ‡§Æ‡§ø‡§ü‡•ç‡§ü‡•Ä ‡§ï‡§æ ‡§™‡•Å‡§®‡§É ‡§™‡§∞‡•Ä‡§ï‡•ç‡§∑‡§£ ‡§ï‡§∞‡•á‡§Ç‡•§",
        "smart_crop_advisor": "‡§∏‡•ç‡§Æ‡§æ‡§∞‡•ç‡§ü ‡§´‡§∏‡§≤ ‡§∏‡§≤‡§æ‡§π‡§ï‡§æ‡§∞",
        "crop_advisor_desc": "‡§Æ‡§ø‡§ü‡•ç‡§ü‡•Ä ‡§ï‡•Ä ‡§∏‡•ç‡§•‡§ø‡§§‡§ø ‡§ï‡•á ‡§Ü‡§ß‡§æ‡§∞ ‡§™‡§∞ ‡§´‡§∏‡§≤ ‡§∏‡§ø‡§´‡§æ‡§∞‡§ø‡§∂‡•á‡§Ç ‡§™‡•ç‡§∞‡§æ‡§™‡•ç‡§§ ‡§ï‡§∞‡•á‡§Ç‡•§",
        "field_conditions": "‡§ñ‡•á‡§§ ‡§ï‡•Ä ‡§∏‡•ç‡§•‡§ø‡§§‡§ø‡§Ø‡§æ‡§Å",
        "analyzing_optimal_crops": "‡§á‡§∑‡•ç‡§ü‡§§‡§Æ ‡§´‡§∏‡§≤‡•ã‡§Ç ‡§ï‡§æ ‡§µ‡§ø‡§∂‡•ç‡§≤‡•á‡§∑‡§£ ‡§ï‡§∞ ‡§∞‡§π‡§æ ‡§π‡•à...",
        "expected_yield": "‡§Ö‡§™‡•á‡§ï‡•ç‡§∑‡§ø‡§§ ‡§â‡§™‡§ú",
        "best_season": "‡§∏‡§∞‡•ç‡§µ‡§∂‡•ç‡§∞‡•á‡§∑‡•ç‡§† ‡§Æ‡•å‡§∏‡§Æ",
        "upload_plant_image_desc": "‡§µ‡§ø‡§∂‡•ç‡§≤‡•á‡§∑‡§£ ‡§ï‡•á ‡§≤‡§ø‡§è ‡§Ö‡§™‡§®‡•á ‡§™‡•å‡§ß‡•á ‡§ï‡•Ä ‡§õ‡§µ‡§ø ‡§Ö‡§™‡§≤‡•ã‡§° ‡§ï‡§∞‡•á‡§Ç‡•§",
        "click_analyze_disease": "‡§™‡•ç‡§∞‡§ï‡•ç‡§∞‡§ø‡§Ø‡§æ ‡§∂‡•Å‡§∞‡•Ç ‡§ï‡§∞‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è '‡§∞‡•ã‡§ó ‡§µ‡§ø‡§∂‡•ç‡§≤‡•á‡§∑‡§£' ‡§™‡§∞ ‡§ï‡•ç‡§≤‡§ø‡§ï ‡§ï‡§∞‡•á‡§Ç‡•§",
        "receive_disease_recommendations": "‡§∞‡•ã‡§ó ‡§™‡§π‡§ö‡§æ‡§® ‡§™‡§∞‡§ø‡§£‡§æ‡§Æ ‡§î‡§∞ ‡§∏‡§ø‡§´‡§æ‡§∞‡§ø‡§∂‡•á‡§Ç ‡§™‡•ç‡§∞‡§æ‡§™‡•ç‡§§ ‡§ï‡§∞‡•á‡§Ç‡•§",
        "upload_plant_image": "‡§™‡•å‡§ß‡•á ‡§ï‡•Ä ‡§õ‡§µ‡§ø ‡§Ö‡§™‡§≤‡•ã‡§° ‡§ï‡§∞‡•á‡§Ç",
        "uploaded_image": "‡§Ö‡§™‡§≤‡•ã‡§° ‡§ï‡•Ä ‡§ó‡§à ‡§õ‡§µ‡§ø",
        "analyze_disease": "‡§∞‡•ã‡§ó ‡§µ‡§ø‡§∂‡•ç‡§≤‡•á‡§∑‡§£",
        "analyzing_disease": "‡§∞‡•ã‡§ó ‡§ï‡§æ ‡§µ‡§ø‡§∂‡•ç‡§≤‡•á‡§∑‡§£ ‡§ï‡§∞ ‡§∞‡§π‡§æ ‡§π‡•à...",
        "disease_detection_results": "‡§∞‡•ã‡§ó ‡§™‡§π‡§ö‡§æ‡§® ‡§™‡§∞‡§ø‡§£‡§æ‡§Æ",
        "consult_expert": "‡§™‡•Å‡§∑‡•ç‡§ü‡•Ä ‡§ï‡•á ‡§≤‡§ø‡§è ‡§∏‡•ç‡§•‡§æ‡§®‡•Ä‡§Ø ‡§ï‡•É‡§∑‡§ø ‡§µ‡§ø‡§∂‡•á‡§∑‡§ú‡•ç‡§û ‡§∏‡•á ‡§™‡§∞‡§æ‡§Æ‡§∞‡•ç‡§∂ ‡§ï‡§∞‡•á‡§Ç‡•§",
        "apply_treatment": "‡§ú‡§≤‡•ç‡§¶ ‡§∏‡•á ‡§ú‡§≤‡•ç‡§¶ ‡§Ö‡§®‡•Å‡§∂‡§Ç‡§∏‡§ø‡§§ ‡§â‡§™‡§ö‡§æ‡§∞ ‡§≤‡§æ‡§ó‡•Ç ‡§ï‡§∞‡•á‡§Ç‡•§",
        "monitor_health": "‡§Ö‡§ó‡§≤‡•á ‡§ï‡•Å‡§õ ‡§π‡§´‡•ç‡§§‡•ã‡§Ç ‡§§‡§ï ‡§™‡•å‡§ß‡•á ‡§ï‡•á ‡§∏‡•ç‡§µ‡§æ‡§∏‡•ç‡§•‡•ç‡§Ø ‡§ï‡•Ä ‡§®‡§ø‡§ó‡§∞‡§æ‡§®‡•Ä ‡§ï‡§∞‡•á‡§Ç‡•§",
        "invalid_image_error": "‡§Ö‡§Æ‡§æ‡§®‡•ç‡§Ø ‡§õ‡§µ‡§ø ‡§´‡§º‡§æ‡§á‡§≤‡•§ ‡§ï‡•É‡§™‡§Ø‡§æ ‡§è‡§ï ‡§Æ‡§æ‡§®‡•ç‡§Ø JPG ‡§Ø‡§æ PNG ‡§õ‡§µ‡§ø ‡§Ö‡§™‡§≤‡•ã‡§° ‡§ï‡§∞‡•á‡§Ç‡•§",
        "error_occurred": "‡§è‡§ï ‡§§‡•ç‡§∞‡•Å‡§ü‡•Ä ‡§π‡•Å‡§à",
        "train_crop_model": "‡§´‡§∏‡§≤ ‡§∏‡§ø‡§´‡§æ‡§∞‡§ø‡§∂ ‡§Æ‡•â‡§°‡§≤ ‡§™‡•ç‡§∞‡§∂‡§ø‡§ï‡•ç‡§∑‡§ø‡§§ ‡§ï‡§∞‡•á‡§Ç"
    },
    "mr": {
        "sidebar_title": "üåæ ‡§è‡§ó‡•ç‡§∞‡•ã‡§¨‡•ç‡§≤‡•Ç‡§Æ ‡§è‡§Ü‡§à",
        "home_title": "üå± ‡§è‡§ó‡•ç‡§∞‡•ã‡§¨‡•ç‡§≤‡•Ç‡§Æ ‡§è‡§Ü‡§à",
        "welcome_message": "‡§è‡§ó‡•ç‡§∞‡•ã‡§¨‡•ç‡§≤‡•Ç‡§Æ ‡§è‡§Ü‡§à ‡§Æ‡§ß‡•ç‡§Ø‡•á ‡§Ü‡§™‡§≤‡•á ‡§∏‡•ç‡§µ‡§æ‡§ó‡§§ ‡§Ü‡§π‡•á - ‡§Ü‡§™‡§≤‡§æ ‡§¨‡•Å‡§¶‡•ç‡§ß‡§ø‡§Æ‡§æ‡§® ‡§∂‡•á‡§§‡•Ä ‡§∏‡§æ‡§•‡•Ä! ‡§ï‡•É‡§§‡•ç‡§∞‡§ø‡§Æ ‡§¨‡•Å‡§¶‡•ç‡§ß‡§ø‡§Æ‡§§‡•ç‡§§‡§æ ‡§ö‡§æ ‡§µ‡§æ‡§™‡§∞ ‡§ï‡§∞‡•Ç‡§® ‡§Ü‡§™‡§≤‡•ç‡§Ø‡§æ ‡§ï‡•É‡§∑‡•Ä ‡§ï‡§æ‡§∞‡•ç‡§Ø‡§æ‡§Ç‡§ö‡•Ä ‡§ï‡§æ‡§∞‡•ç‡§Ø‡§ï‡•ç‡§∑‡§Æ‡§§‡§æ ‡§µ‡§æ‡§¢‡§µ‡§æ, ‡§™‡•Ä‡§ï ‡§â‡§§‡•ç‡§™‡§æ‡§¶‡§® ‡§µ‡§æ‡§¢‡§µ‡§æ ‡§Ü‡§£‡§ø ‡§∂‡§æ‡§∂‡•ç‡§µ‡§§ ‡§∂‡•á‡§§‡•Ä‡§∏‡§æ‡§†‡•Ä ‡§°‡•á‡§ü‡§æ-‡§Ü‡§ß‡§æ‡§∞‡§ø‡§§ ‡§®‡§ø‡§∞‡•ç‡§£‡§Ø ‡§ò‡•ç‡§Ø‡§æ.",
        "weather_report": "‡§∏‡§æ‡§†‡•Ä ‡§π‡§µ‡§æ‡§Æ‡§æ‡§® ‡§Ö‡§π‡§µ‡§æ‡§≤",
        "farming_advisory": "‡§∂‡•á‡§§‡•Ä ‡§∏‡§≤‡•ç‡§≤‡§æ",
        "soil_moisture_map": "‡§Æ‡§æ‡§§‡•Ä‡§ö‡•Ä ‡§Ü‡§∞‡•ç‡§¶‡•ç‡§∞‡§§‡§æ ‡§®‡§ï‡§æ‡§∂‡§æ",
        "current_conditions": "‡§∏‡§ß‡•ç‡§Ø‡§æ‡§ö‡•ç‡§Ø‡§æ ‡§™‡§∞‡§ø‡§∏‡•ç‡§•‡§ø‡§§‡•Ä",
        "select_language": "‡§≠‡§æ‡§∑‡§æ ‡§®‡§ø‡§µ‡§°‡§æ",
        "home": "‡§Æ‡•Å‡§ñ‡§™‡•É‡§∑‡•ç‡§†",
        "weather_forecasting": "‡§π‡§µ‡§æ‡§Æ‡§æ‡§® ‡§Ö‡§Ç‡§¶‡§æ‡§ú",
        "irrigation_management": "‡§∏‡§ø‡§Ç‡§ö‡§® ‡§µ‡•ç‡§Ø‡§µ‡§∏‡•ç‡§•‡§æ‡§™‡§®",
        "soil_health_analysis": "‡§Æ‡§æ‡§§‡•Ä ‡§Ü‡§∞‡•ã‡§ó‡•ç‡§Ø ‡§µ‡§ø‡§∂‡•ç‡§≤‡•á‡§∑‡§£",
        "disease_detection": "‡§∞‡•ã‡§ó ‡§∂‡•ã‡§ß",
        "ai_assistant": "‡§è‡§Ü‡§Ø ‡§∏‡§π‡§æ‡§Ø‡§ï",
        "navigation": "‡§®‡•á‡§µ‡•ç‡§π‡§ø‡§ó‡•á‡§∂‡§®",
        "smart_weather_insights": "‡§∏‡•ç‡§Æ‡§æ‡§∞‡•ç‡§ü ‡§π‡§µ‡§æ‡§Æ‡§æ‡§® ‡§Ö‡§Ç‡§§‡§∞‡•ç‡§¶‡•É‡§∑‡•ç‡§ü‡•Ä",
        "smart_weather_desc": "‡§Ü‡§™‡§≤‡•ç‡§Ø‡§æ ‡§∏‡•ç‡§•‡§æ‡§®‡§æ‡§µ‡§∞ ‡§Ü‡§ß‡§æ‡§∞‡§ø‡§§ ‡§µ‡§æ‡§∏‡•ç‡§§‡§µ‡§ø‡§ï ‡§µ‡•á‡§≥ ‡§π‡§µ‡§æ‡§Æ‡§æ‡§® ‡§°‡•á‡§ü‡§æ ‡§Ü‡§£‡§ø ‡§∂‡•á‡§§‡•Ä ‡§∏‡§≤‡•ç‡§≤‡§æ ‡§Æ‡§ø‡§≥‡§µ‡§æ.",
        "ai_irrigation_system": "‡§è‡§Ü‡§Ø-‡§ö‡§æ‡§≤‡§ø‡§§ ‡§∏‡§ø‡§Ç‡§ö‡§® ‡§™‡•ç‡§∞‡§£‡§æ‡§≤‡•Ä",
        "ai_irrigation_desc": "‡§≠‡§µ‡§ø‡§∑‡•ç‡§Ø‡§∏‡•Ç‡§ö‡§ï ‡§µ‡§ø‡§∂‡•ç‡§≤‡•á‡§∑‡§£ ‡§Ü‡§£‡§ø ‡§µ‡§æ‡§∏‡•ç‡§§‡§µ‡§ø‡§ï ‡§µ‡•á‡§≥ ‡§Æ‡§æ‡§§‡•Ä ‡§Ü‡§∞‡•ç‡§¶‡•ç‡§∞‡§§‡§æ ‡§°‡•á‡§ü‡§æ ‡§∏‡§π ‡§™‡§æ‡§£‡•ç‡§Ø‡§æ‡§ö‡§æ ‡§µ‡§æ‡§™‡§∞ ‡§Ö‡§®‡•Å‡§ï‡•Ç‡§≤ ‡§ï‡§∞‡§æ.",
        "soil_health_dashboard": "‡§Æ‡§æ‡§§‡•Ä ‡§Ü‡§∞‡•ã‡§ó‡•ç‡§Ø ‡§°‡•Ö‡§∂‡§¨‡•ã‡§∞‡•ç‡§°",
        "soil_health_desc": "‡§Æ‡§æ‡§§‡•Ä‡§ö‡•ç‡§Ø‡§æ ‡§Æ‡§æ‡§™‡§¶‡§Ç‡§°‡§æ‡§Ç‡§ö‡•á ‡§µ‡§ø‡§∂‡•ç‡§≤‡•á‡§∑‡§£ ‡§ï‡§∞‡§æ ‡§Ü‡§£‡§ø ‡§∏‡•Å‡§ß‡§æ‡§∞‡§£‡•á‡§∏‡§æ‡§†‡•Ä ‡§â‡§™‡§Ø‡•Å‡§ï‡•ç‡§§ ‡§Ö‡§Ç‡§§‡§∞‡•ç‡§¶‡•É‡§∑‡•ç‡§ü‡•Ä ‡§Æ‡§ø‡§≥‡§µ‡§æ.",
        "disease_detection_title": "‡§µ‡§®‡§∏‡•ç‡§™‡§§‡•Ä ‡§∞‡•ã‡§ó ‡§∂‡•ã‡§ß",
        "disease_detection_desc": "‡§∞‡•ã‡§ó ‡§∂‡•ã‡§ß‡§£‡•ç‡§Ø‡§æ‡§∏‡§æ‡§†‡•Ä ‡§Ü‡§£‡§ø ‡§â‡§™‡§ö‡§æ‡§∞ ‡§∂‡§ø‡§´‡§æ‡§∞‡§∂‡•Ä ‡§Æ‡§ø‡§≥‡§µ‡§£‡•ç‡§Ø‡§æ‡§∏‡§æ‡§†‡•Ä ‡§µ‡§®‡§∏‡•ç‡§™‡§§‡•Ä‡§Ç‡§ö‡•Ä ‡§õ‡§æ‡§Ø‡§æ‡§ö‡§ø‡§§‡•ç‡§∞‡•á ‡§Ö‡§™‡§≤‡•ã‡§° ‡§ï‡§∞‡§æ.",
        "join_revolution": "‡§ï‡•É‡§∑‡•Ä ‡§ï‡•ç‡§∞‡§æ‡§Ç‡§§‡•Ä‡§§ ‡§∏‡§æ‡§Æ‡•Ä‡§≤ ‡§µ‡•ç‡§π‡§æ",
        "start_journey": "‡§Ü‡§ú‡§ö ‡§∏‡•ç‡§Æ‡§æ‡§∞‡•ç‡§ü ‡§∂‡•á‡§§‡•Ä‡§ï‡§°‡•á ‡§Ü‡§™‡§≤‡•Ä ‡§Ø‡§æ‡§§‡•ç‡§∞‡§æ ‡§∏‡•Å‡§∞‡•Ç ‡§ï‡§∞‡§æ!",
        "enter_location": "‡§∏‡•ç‡§•‡§æ‡§® ‡§™‡•ç‡§∞‡§µ‡§ø‡§∑‡•ç‡§ü ‡§ï‡§∞‡§æ",
        "get_weather_analysis": "‡§π‡§µ‡§æ‡§Æ‡§æ‡§® ‡§µ‡§ø‡§∂‡•ç‡§≤‡•á‡§∑‡§£ ‡§Æ‡§ø‡§≥‡§µ‡§æ",
        "fetching_weather_data": "‡§π‡§µ‡§æ‡§Æ‡§æ‡§® ‡§°‡•á‡§ü‡§æ ‡§Æ‡§ø‡§≥‡§µ‡§§ ‡§Ü‡§π‡•á...",
        "temperature": "‡§§‡§æ‡§™‡§Æ‡§æ‡§®",
        "humidity": "‡§Ü‡§∞‡•ç‡§¶‡•ç‡§∞‡§§‡§æ",
        "precipitation": "‡§™‡§∞‡•ç‡§ú‡§®‡•ç‡§Ø‡§Æ‡§æ‡§®",
        "wind_speed": "‡§µ‡§æ‡§±‡•ç‡§Ø‡§æ‡§ö‡§æ ‡§µ‡•á‡§ó",
        "frost_alert": "‡§π‡§ø‡§Æ ‡§ö‡•á‡§§‡§æ‡§µ‡§®‡•Ä: ‡§∏‡§Ç‡§µ‡•á‡§¶‡§®‡§∂‡•Ä‡§≤ ‡§™‡§ø‡§ï‡§æ‡§Ç‡§®‡§æ ‡§ï‡§Æ‡•Ä ‡§§‡§æ‡§™‡§Æ‡§æ‡§®‡§æ‡§™‡§æ‡§∏‡•Ç‡§® ‡§∏‡§Ç‡§∞‡§ï‡•ç‡§∑‡§£ ‡§¶‡•ç‡§Ø‡§æ.",
        "cool_weather": "‡§•‡§Ç‡§° ‡§π‡§µ‡§æ‡§Æ‡§æ‡§®: ‡§Ø‡•ã‡§ó‡•ç‡§Ø ‡§ï‡§æ‡§≥‡§ú‡•Ä‡§∏‡§π ‡§¨‡§π‡•Å‡§§‡•á‡§ï ‡§™‡§ø‡§ï‡§æ‡§Ç‡§∏‡§æ‡§†‡•Ä ‡§Ø‡•ã‡§ó‡•ç‡§Ø.",
        "optimal_conditions": "‡§á‡§∑‡•ç‡§ü‡§§‡§Æ ‡§™‡§∞‡§ø‡§∏‡•ç‡§•‡§ø‡§§‡•Ä: ‡§™‡•Ä‡§ï ‡§µ‡§æ‡§¢‡•Ä‡§∏‡§æ‡§†‡•Ä ‡§Ü‡§¶‡§∞‡•ç‡§∂ ‡§π‡§µ‡§æ‡§Æ‡§æ‡§®.",
        "heat_stress": "‡§â‡§∑‡•ç‡§£‡§§‡§æ ‡§§‡§£‡§æ‡§µ: ‡§â‡§ö‡•ç‡§ö ‡§§‡§æ‡§™‡§Æ‡§æ‡§® ‡§ï‡§Æ‡•Ä ‡§ï‡§∞‡§£‡•ç‡§Ø‡§æ‡§∏‡§æ‡§†‡•Ä ‡§Ø‡•ã‡§ó‡•ç‡§Ø ‡§∏‡§ø‡§Ç‡§ö‡§® ‡§∏‡•Å‡§®‡§ø‡§∂‡•ç‡§ö‡§ø‡§§ ‡§ï‡§∞‡§æ.",
        "failed_to_retrieve_weather_data": "‡§π‡§µ‡§æ‡§Æ‡§æ‡§® ‡§°‡•á‡§ü‡§æ ‡§Æ‡§ø‡§≥‡§µ‡§£‡•ç‡§Ø‡§æ‡§§ ‡§Ö‡§Ø‡§∂‡§∏‡•ç‡§µ‡•Ä. ‡§ï‡•É‡§™‡§Ø‡§æ ‡§∏‡•ç‡§•‡§æ‡§® ‡§§‡§™‡§æ‡§∏‡§æ ‡§Ü‡§£‡§ø ‡§™‡•Å‡§®‡•ç‡§π‡§æ ‡§™‡•ç‡§∞‡§Ø‡§§‡•ç‡§® ‡§ï‡§∞‡§æ.",
        "smart_irrigation_system": "‡§∏‡•ç‡§Æ‡§æ‡§∞‡•ç‡§ü ‡§∏‡§ø‡§Ç‡§ö‡§® ‡§™‡•ç‡§∞‡§£‡§æ‡§≤‡•Ä",
        "irrigation_desc": "‡§∏‡§ø‡§Ç‡§ö‡§® ‡§ï‡§æ‡§∞‡•ç‡§Ø‡§ï‡•ç‡§∑‡§Æ‡§§‡•á‡§®‡•á ‡§µ‡•ç‡§Ø‡§µ‡§∏‡•ç‡§•‡§æ‡§™‡§ø‡§§ ‡§ï‡§∞‡§£‡•ç‡§Ø‡§æ‡§∏‡§æ‡§†‡•Ä ‡§è‡§Ü‡§Ø‡§ö‡§æ ‡§µ‡§æ‡§™‡§∞ ‡§ï‡§∞‡§æ.",
        "field_parameters": "‡§∂‡•á‡§§ ‡§Æ‡§æ‡§™‡§¶‡§Ç‡§°",
        "select_region_category": "‡§™‡•ç‡§∞‡§¶‡•á‡§∂ ‡§∂‡•ç‡§∞‡•á‡§£‡•Ä ‡§®‡§ø‡§µ‡§°‡§æ",
        "select_location": "‡§∏‡•ç‡§•‡§æ‡§® ‡§®‡§ø‡§µ‡§°‡§æ",
        "use_custom_location": "‡§∏‡§æ‡§®‡•Å‡§ï‡•Ç‡§≤ ‡§∏‡•ç‡§•‡§æ‡§® ‡§µ‡§æ‡§™‡§∞‡§æ",
        "enter_custom_location": "‡§∏‡§æ‡§®‡•Å‡§ï‡•Ç‡§≤ ‡§∏‡•ç‡§•‡§æ‡§® ‡§™‡•ç‡§∞‡§µ‡§ø‡§∑‡•ç‡§ü ‡§ï‡§∞‡§æ",
        "crop_type": "‡§™‡•Ä‡§ï ‡§™‡•ç‡§∞‡§ï‡§æ‡§∞",
        "optimal_moisture_tip": "‡§á‡§∑‡•ç‡§ü‡§§‡§Æ ‡§Ü‡§∞‡•ç‡§¶‡•ç‡§∞‡§§‡§æ ‡§™‡•Ä‡§ï ‡§™‡•ç‡§∞‡§ï‡§æ‡§∞‡§æ‡§®‡•Å‡§∏‡§æ‡§∞ ‡§¨‡§¶‡§≤‡§§‡•á.",
        "calculate_irrigation": "‡§∏‡§ø‡§Ç‡§ö‡§®‡§æ‡§ö‡•Ä ‡§ó‡§∞‡§ú ‡§Æ‡•ã‡§ú‡§æ",
        "analyzing_field_conditions": "‡§∂‡•á‡§§‡§æ‡§ö‡•ç‡§Ø‡§æ ‡§™‡§∞‡§ø‡§∏‡•ç‡§•‡§ø‡§§‡•Ä‡§ö‡•á ‡§µ‡§ø‡§∂‡•ç‡§≤‡•á‡§∑‡§£ ‡§ï‡§∞‡§§ ‡§Ü‡§π‡•á...",
        "irrigation_plan": "‡§∏‡§ø‡§Ç‡§ö‡§® ‡§Ø‡•ã‡§ú‡§®‡§æ",
        "irrigation_analysis": "‡§∏‡§ø‡§Ç‡§ö‡§® ‡§µ‡§ø‡§∂‡•ç‡§≤‡•á‡§∑‡§£",
        "soil_moisture": "‡§Æ‡§æ‡§§‡•Ä‡§ö‡•Ä ‡§Ü‡§∞‡•ç‡§¶‡•ç‡§∞‡§§‡§æ",
        "soil_moisture_level": "‡§Æ‡§æ‡§§‡•Ä‡§ö‡•Ä ‡§Ü‡§∞‡•ç‡§¶‡•ç‡§∞‡§§‡§æ ‡§™‡§æ‡§§‡§≥‡•Ä",
        "crop_specific_analysis": "‡§™‡•Ä‡§ï-‡§µ‡§ø‡§∂‡§ø‡§∑‡•ç‡§ü ‡§µ‡§ø‡§∂‡•ç‡§≤‡•á‡§∑‡§£",
        "optimal_soil_moisture_range": "‡§á‡§∑‡•ç‡§ü‡§§‡§Æ ‡§Æ‡§æ‡§§‡•Ä ‡§Ü‡§∞‡•ç‡§¶‡•ç‡§∞‡§§‡§æ ‡§∂‡•ç‡§∞‡•á‡§£‡•Ä",
        "below_optimal": "{crop_type} ‡§∏‡§æ‡§†‡•Ä ‡§Æ‡§æ‡§§‡•Ä‡§ö‡•Ä ‡§Ü‡§∞‡•ç‡§¶‡•ç‡§∞‡§§‡§æ ‡§á‡§∑‡•ç‡§ü‡§§‡§Æ‡§™‡•á‡§ï‡•ç‡§∑‡§æ ‡§ï‡§Æ‡•Ä ‡§Ü‡§π‡•á. ‡§∏‡§ø‡§Ç‡§ö‡§®‡§æ‡§ö‡§æ ‡§µ‡§ø‡§ö‡§æ‡§∞ ‡§ï‡§∞‡§æ.",
        "above_optimal": "{crop_type} ‡§∏‡§æ‡§†‡•Ä ‡§Æ‡§æ‡§§‡•Ä‡§ö‡•Ä ‡§Ü‡§∞‡•ç‡§¶‡•ç‡§∞‡§§‡§æ ‡§á‡§∑‡•ç‡§ü‡§§‡§Æ‡§™‡•á‡§ï‡•ç‡§∑‡§æ ‡§ú‡§æ‡§∏‡•ç‡§§ ‡§Ü‡§π‡•á. ‡§∏‡§ø‡§Ç‡§ö‡§® ‡§ï‡§Æ‡•Ä ‡§ï‡§∞‡§æ.",
        "within_optimal": "{crop_type} ‡§∏‡§æ‡§†‡•Ä ‡§Æ‡§æ‡§§‡•Ä‡§ö‡•Ä ‡§Ü‡§∞‡•ç‡§¶‡•ç‡§∞‡§§‡§æ ‡§á‡§∑‡•ç‡§ü‡§§‡§Æ ‡§∂‡•ç‡§∞‡•á‡§£‡•Ä‡§§ ‡§Ü‡§π‡•á.",
        "water_conservation_impact": "‡§ú‡§≤ ‡§∏‡§Ç‡§∞‡§ï‡•ç‡§∑‡§£ ‡§™‡•ç‡§∞‡§≠‡§æ‡§µ",
        "monthly_savings": "‡§Æ‡§æ‡§∏‡§ø‡§ï ‡§¨‡§ö‡§§",
        "water_saved": "‡§™‡§æ‡§£‡•Ä ‡§µ‡§æ‡§ö‡§≤‡•á",
        "cost_reduction": "‡§ñ‡§∞‡•ç‡§ö‡§æ‡§§ ‡§ï‡§™‡§æ‡§§",
        "environmental_impact": "‡§™‡§∞‡•ç‡§Ø‡§æ‡§µ‡§∞‡§£‡•Ä‡§Ø ‡§™‡•ç‡§∞‡§≠‡§æ‡§µ",
        "carbon_footprint_reduction": "‡§ï‡§æ‡§∞‡•ç‡§¨‡§® ‡§´‡•Ç‡§ü‡§™‡•ç‡§∞‡§ø‡§Ç‡§ü ‡§ï‡§Æ‡•Ä ‡§ï‡§∞‡§£‡•á",
        "sustainability_score": "‡§∂‡§æ‡§∂‡•ç‡§µ‡§§‡§§‡§æ ‡§ó‡•Å‡§£",
        "how_to_use": "‡§ï‡§∏‡•á ‡§µ‡§æ‡§™‡§∞‡§æ‡§µ‡•á",
        "input_soil_test_results": "‡§ñ‡§æ‡§≤‡•Ä ‡§Ü‡§™‡§≤‡•á ‡§Æ‡§æ‡§§‡•Ä ‡§ö‡§æ‡§ö‡§£‡•Ä ‡§™‡§∞‡§ø‡§£‡§æ‡§Æ ‡§™‡•ç‡§∞‡§µ‡§ø‡§∑‡•ç‡§ü ‡§ï‡§∞‡§æ.",
        "click_analyze_soil_health": "‡§°‡•á‡§ü‡§æ ‡§™‡•ç‡§∞‡§ï‡•ç‡§∞‡§ø‡§Ø‡§æ ‡§ï‡§∞‡§£‡•ç‡§Ø‡§æ‡§∏‡§æ‡§†‡•Ä '‡§Æ‡§æ‡§§‡•Ä ‡§Ü‡§∞‡•ã‡§ó‡•ç‡§Ø ‡§µ‡§ø‡§∂‡•ç‡§≤‡•á‡§∑‡§£' ‡§µ‡§∞ ‡§ï‡•ç‡§≤‡§ø‡§ï ‡§ï‡§∞‡§æ.",
        "receive_recommendations": "‡§Æ‡§æ‡§§‡•Ä ‡§∏‡•Å‡§ß‡§æ‡§∞‡§£‡•á‡§∏‡§æ‡§†‡•Ä ‡§∏‡§æ‡§®‡•Å‡§ï‡•Ç‡§≤‡§ø‡§§ ‡§∂‡§ø‡§´‡§æ‡§∞‡§∂‡•Ä ‡§Æ‡§ø‡§≥‡§µ‡§æ.",
        "soil_parameters": "‡§Æ‡§æ‡§§‡•Ä ‡§Æ‡§æ‡§™‡§¶‡§Ç‡§°",
        "soil_ph": "‡§Æ‡§æ‡§§‡•Ä ‡§™‡•Ä‡§è‡§ö",
        "nitrogen": "‡§®‡§æ‡§Ø‡§ü‡•ç‡§∞‡•ã‡§ú‡§® (‡§ï‡§ø‡§ó‡•ç‡§∞‡§æ/‡§π‡•á‡§ï‡•ç‡§ü‡§∞)",
        "phosphorus": "‡§´‡•â‡§∏‡•ç‡§´‡§∞‡§∏ (‡§ï‡§ø‡§ó‡•ç‡§∞‡§æ/‡§π‡•á‡§ï‡•ç‡§ü‡§∞)",
        "potassium": "‡§™‡•ã‡§ü‡•Ö‡§∂‡§ø‡§Ø‡§Æ (‡§ï‡§ø‡§ó‡•ç‡§∞‡§æ/‡§π‡•á‡§ï‡•ç‡§ü‡§∞)",
        "organic_matter": "‡§∏‡•á‡§Ç‡§¶‡•ç‡§∞‡§ø‡§Ø ‡§™‡§¶‡§æ‡§∞‡•ç‡§• (%)",
        "analyze_soil_health": "‡§Æ‡§æ‡§§‡•Ä ‡§Ü‡§∞‡•ã‡§ó‡•ç‡§Ø ‡§µ‡§ø‡§∂‡•ç‡§≤‡•á‡§∑‡§£",
        "analyzing_soil_composition": "‡§Æ‡§æ‡§§‡•Ä ‡§∏‡§Ç‡§∞‡§ö‡§®‡•á‡§ö‡•á ‡§µ‡§ø‡§∂‡•ç‡§≤‡•á‡§∑‡§£ ‡§ï‡§∞‡§§ ‡§Ü‡§π‡•á...",
        "analysis_results": "‡§µ‡§ø‡§∂‡•ç‡§≤‡•á‡§∑‡§£ ‡§™‡§∞‡§ø‡§£‡§æ‡§Æ",
        "recommended_actions": "‡§∂‡§ø‡§´‡§æ‡§∞‡§∏ ‡§ï‡•á‡§≤‡•á‡§≤‡•ç‡§Ø‡§æ ‡§ï‡•É‡§§‡•Ä",
        "apply_organic_compost": "‡§∏‡•á‡§Ç‡§¶‡•ç‡§∞‡§ø‡§Ø ‡§ñ‡§æ‡§¶ ‡§≤‡§æ‡§µ‡§æ ‡§ú‡•á‡§£‡•á‡§ï‡§∞‡•Ç‡§® ‡§∏‡•á‡§Ç‡§¶‡•ç‡§∞‡§ø‡§Ø ‡§™‡§¶‡§æ‡§∞‡•ç‡§•‡§æ‡§§ ‡§∏‡•Å‡§ß‡§æ‡§∞‡§£‡§æ ‡§π‡•ã‡§à‡§≤.",
        "ideal_soil_ph": "‡§Ü‡§µ‡§∂‡•ç‡§Ø‡§ï ‡§Ö‡§∏‡§≤‡•ç‡§Ø‡§æ‡§∏ ‡§™‡•Ä‡§è‡§ö 6.0-7.5 ‡§™‡§∞‡•ç‡§Ø‡§Ç‡§§ ‡§∏‡§Æ‡§æ‡§Ø‡•ã‡§ú‡§ø‡§§ ‡§ï‡§∞‡§æ.",
        "ideal_nitrogen": "‡§®‡§æ‡§Ø‡§ü‡•ç‡§∞‡•ã‡§ú‡§® ‡§™‡§æ‡§§‡§≥‡•Ä 20-50 ‡§ï‡§ø‡§ó‡•ç‡§∞‡§æ/‡§π‡•á‡§ï‡•ç‡§ü‡§∞ ‡§¶‡§∞‡§Æ‡•ç‡§Ø‡§æ‡§® ‡§†‡•á‡§µ‡§æ.",
        "ideal_phosphorus": "‡§´‡•â‡§∏‡•ç‡§´‡§∞‡§∏ ‡§™‡§æ‡§§‡§≥‡•Ä 15-40 ‡§ï‡§ø‡§ó‡•ç‡§∞‡§æ/‡§π‡•á‡§ï‡•ç‡§ü‡§∞ ‡§¶‡§∞‡§Æ‡•ç‡§Ø‡§æ‡§® ‡§†‡•á‡§µ‡§æ.",
        "ideal_potassium": "‡§™‡•ã‡§ü‡•Ö‡§∂‡§ø‡§Ø‡§Æ ‡§™‡§æ‡§§‡§≥‡•Ä 15-40 ‡§ï‡§ø‡§ó‡•ç‡§∞‡§æ/‡§π‡•á‡§ï‡•ç‡§ü‡§∞ ‡§¶‡§∞‡§Æ‡•ç‡§Ø‡§æ‡§® ‡§†‡•á‡§µ‡§æ.",
        "retest_soil": "3 ‡§Æ‡§π‡§ø‡§®‡•ç‡§Ø‡§æ‡§Ç‡§®‡§Ç‡§§‡§∞ ‡§Æ‡§æ‡§§‡•Ä‡§ö‡•Ä ‡§™‡•Å‡§®‡•ç‡§π‡§æ ‡§ö‡§æ‡§ö‡§£‡•Ä ‡§ï‡§∞‡§æ.",
        "smart_crop_advisor": "‡§∏‡•ç‡§Æ‡§æ‡§∞‡•ç‡§ü ‡§™‡•Ä‡§ï ‡§∏‡§≤‡•ç‡§≤‡§æ‡§ó‡§æ‡§∞",
        "crop_advisor_desc": "‡§Æ‡§æ‡§§‡•Ä‡§ö‡•ç‡§Ø‡§æ ‡§™‡§∞‡§ø‡§∏‡•ç‡§•‡§ø‡§§‡•Ä‡§µ‡§∞ ‡§Ü‡§ß‡§æ‡§∞‡§ø‡§§ ‡§™‡•Ä‡§ï ‡§∂‡§ø‡§´‡§æ‡§∞‡§∂‡•Ä ‡§Æ‡§ø‡§≥‡§µ‡§æ.",
        "field_conditions": "‡§∂‡•á‡§§ ‡§™‡§∞‡§ø‡§∏‡•ç‡§•‡§ø‡§§‡•Ä",
        "analyzing_optimal_crops": "‡§á‡§∑‡•ç‡§ü‡§§‡§Æ ‡§™‡§ø‡§ï‡§æ‡§Ç‡§ö‡•á ‡§µ‡§ø‡§∂‡•ç‡§≤‡•á‡§∑‡§£ ‡§ï‡§∞‡§§ ‡§Ü‡§π‡•á...",
        "expected_yield": "‡§Ö‡§™‡•á‡§ï‡•ç‡§∑‡§ø‡§§ ‡§â‡§§‡•ç‡§™‡§æ‡§¶‡§®",
        "best_season": "‡§∏‡§∞‡•ç‡§µ‡•ã‡§§‡•ç‡§§‡§Æ ‡§π‡§Ç‡§ó‡§æ‡§Æ",
        "upload_plant_image_desc": "‡§µ‡§ø‡§∂‡•ç‡§≤‡•á‡§∑‡§£‡§æ‡§∏‡§æ‡§†‡•Ä ‡§Ü‡§™‡§≤‡•ç‡§Ø‡§æ ‡§µ‡§®‡§∏‡•ç‡§™‡§§‡•Ä‡§ö‡•á ‡§ö‡§ø‡§§‡•ç‡§∞ ‡§Ö‡§™‡§≤‡•ã‡§° ‡§ï‡§∞‡§æ.",
        "click_analyze_disease": "‡§™‡•ç‡§∞‡§ï‡•ç‡§∞‡§ø‡§Ø‡§æ ‡§∏‡•Å‡§∞‡•Ç ‡§ï‡§∞‡§£‡•ç‡§Ø‡§æ‡§∏‡§æ‡§†‡•Ä '‡§∞‡•ã‡§ó ‡§µ‡§ø‡§∂‡•ç‡§≤‡•á‡§∑‡§£' ‡§µ‡§∞ ‡§ï‡•ç‡§≤‡§ø‡§ï ‡§ï‡§∞‡§æ.",
        "receive_disease_recommendations": "‡§∞‡•ã‡§ó ‡§∂‡•ã‡§ß ‡§™‡§∞‡§ø‡§£‡§æ‡§Æ ‡§Ü‡§£‡§ø ‡§∂‡§ø‡§´‡§æ‡§∞‡§∂‡•Ä ‡§Æ‡§ø‡§≥‡§µ‡§æ.",
        "upload_plant_image": "‡§µ‡§®‡§∏‡•ç‡§™‡§§‡•Ä ‡§ö‡§ø‡§§‡•ç‡§∞ ‡§Ö‡§™‡§≤‡•ã‡§° ‡§ï‡§∞‡§æ",
        "uploaded_image": "‡§Ö‡§™‡§≤‡•ã‡§° ‡§ï‡•á‡§≤‡•á‡§≤‡•á ‡§ö‡§ø‡§§‡•ç‡§∞",
        "analyze_disease": "‡§∞‡•ã‡§ó ‡§µ‡§ø‡§∂‡•ç‡§≤‡•á‡§∑‡§£",
        "analyzing_disease": "‡§∞‡•ã‡§ó‡§æ‡§ö‡•á ‡§µ‡§ø‡§∂‡•ç‡§≤‡•á‡§∑‡§£ ‡§ï‡§∞‡§§ ‡§Ü‡§π‡•á...",
        "disease_detection_results": "‡§∞‡•ã‡§ó ‡§∂‡•ã‡§ß ‡§™‡§∞‡§ø‡§£‡§æ‡§Æ",
        "consult_expert": "‡§™‡•Å‡§∑‡•ç‡§ü‡•Ä‡§ï‡§∞‡§£‡§æ‡§∏‡§æ‡§†‡•Ä ‡§∏‡•ç‡§•‡§æ‡§®‡§ø‡§ï ‡§ï‡•É‡§∑‡•Ä ‡§§‡§ú‡•ç‡§û‡§æ‡§ö‡§æ ‡§∏‡§≤‡•ç‡§≤‡§æ ‡§ò‡•ç‡§Ø‡§æ‡•§",
        "apply_treatment": "‡§∂‡§ï‡•ç‡§Ø ‡§§‡§ø‡§§‡§ï‡•ç‡§Ø‡§æ ‡§≤‡§µ‡§ï‡§∞ ‡§∂‡§ø‡§´‡§æ‡§∞‡§∏ ‡§ï‡•á‡§≤‡•á‡§≤‡•á ‡§â‡§™‡§ö‡§æ‡§∞ ‡§≤‡§æ‡§ó‡•Ç ‡§ï‡§∞‡§æ‡•§",
        "monitor_health": "‡§™‡•Å‡§¢‡•Ä‡§≤ ‡§ï‡§æ‡§π‡•Ä ‡§Ü‡§†‡§µ‡§°‡•ç‡§Ø‡§æ‡§Ç‡§™‡§∞‡•ç‡§Ø‡§Ç‡§§ ‡§µ‡§®‡§∏‡•ç‡§™‡§§‡•Ä‡§ö‡•ç‡§Ø‡§æ ‡§Ü‡§∞‡•ã‡§ó‡•ç‡§Ø‡§æ‡§µ‡§∞ ‡§≤‡§ï‡•ç‡§∑ ‡§†‡•á‡§µ‡§æ‡•§",
        "invalid_image_error": "‡§Ö‡§µ‡•à‡§ß ‡§ö‡§ø‡§§‡•ç‡§∞ ‡§´‡§æ‡§á‡§≤. ‡§ï‡•É‡§™‡§Ø‡§æ ‡§µ‡•à‡§ß JPG ‡§ï‡§ø‡§Ç‡§µ‡§æ PNG ‡§ö‡§ø‡§§‡•ç‡§∞ ‡§Ö‡§™‡§≤‡•ã‡§° ‡§ï‡§∞‡§æ‡•§",
        "error_occurred": "‡§è‡§ï ‡§§‡•ç‡§∞‡•Å‡§ü‡•Ä ‡§Ü‡§≤‡•Ä",
        "train_crop_model": "‡§´‡§∏‡§≤ ‡§∏‡§ø‡§´‡§æ‡§∞‡§ø‡§∂ ‡§Æ‡•â‡§°‡•á‡§≤ ‡§™‡•ç‡§∞‡§∂‡§ø‡§ï‡•ç‡§∑‡§ø‡§§ ‡§ï‡§∞‡§æ"
    }
}

# Global variable to store the current language code
current_language = "en"

def tr(key):
    return translations.get(current_language, translations["en"]).get(key, key)

# Placeholder for suggested regions
suggested_regions = {
    "India": ["Mumbai", "Delhi", "Bangalore"]
}

# Initialize Earth Engine
def initialize_ee():
    try:
        project_id = os.getenv("GEE_PROJECT_ID", "agrobloom-ai")
        ee.Initialize(project=project_id)
    except Exception as e:
        try:
            ee.Authenticate()
            project_id = os.getenv("GEE_PROJECT_ID", "agrobloom-ai")
            ee.Initialize(project=project_id)
        except Exception as auth_e:
            st.error(f"Error initializing Google Earth Engine: {str(auth_e)}")
            return False
    return True

ee_initialized = initialize_ee()

# -------------------- Text-to-Speech Function --------------------
def text_to_speech(text, language='en'):
    """
    Convert text to speech and play it.
    """
    try:
        # Create a temporary file to store the audio
        with tempfile.NamedTemporaryFile(delete=False, suffix=".mp3") as temp_audio_file:
            tts = gTTS(text=text, lang=language, slow=False)
            tts.save(temp_audio_file.name)
            st.audio(temp_audio_file.name, format="audio/mp3")
    except Exception as e:
        st.error(f"Error in text-to-speech conversion: {str(e)}")

# -------------------- Speech-to-Text Function --------------------
def speech_to_text():
    """
    Convert speech to text using the microphone.
    """
    recognizer = sr.Recognizer()
    with sr.Microphone() as source:
        st.write("Listening... Speak now!")
        try:
            audio = recognizer.listen(source, timeout=5)  # Listen for 5 seconds
            text = recognizer.recognize_google(audio)
            return text
        except sr.UnknownValueError:
            st.warning("Sorry, I could not understand the audio.")
        except sr.RequestError as e:
            st.error(f"Could not request results from Google Speech Recognition service; {str(e)}")
        except Exception as e:
            st.error(f"Error in speech-to-text conversion: {str(e)}")
    return None


# Function to get soil moisture data
def get_soil_moisture(lat, lon):
    if not ee_initialized:
        st.error("Earth Engine not initialized.")
        return None
    try:
        point = ee.Geometry.Point([lon, lat])
        region = point.buffer(1000)
        end_date = datetime.now()
        start_date = end_date - timedelta(days=7)
        collection = ee.ImageCollection('ECMWF/ERA5_LAND/HOURLY')\
            .filterDate(start_date.strftime('%Y-%m-%d'), end_date.strftime('%Y-%m-%d'))\
            .select('volumetric_soil_water_layer_1')
        collection_size = collection.size().getInfo()
        if collection_size == 0:
            start_date = end_date - timedelta(days=30)
            collection = ee.ImageCollection('ECMWF/ERA5_LAND/HOURLY')\
                .filterDate(start_date.strftime('%Y-%m-%d'), end_date.strftime('%Y-%m-%d'))\
                .select('volumetric_soil_water_layer_1')
            collection_size = collection.size().getInfo()
            if collection_size == 0:
                st.error("No soil moisture data available.")
                return None
        def get_region_mean(image):
            mean = image.reduceRegion(reducer=ee.Reducer.mean(), geometry=region, scale=1000)
            return image.set('mean', mean.get('volumetric_soil_water_layer_1'))
        collection_with_means = collection.map(get_region_mean)
        sorted_collection = collection_with_means.sort('system:time_start', False)
        recent_value = sorted_collection.first().get('mean').getInfo()
        if recent_value is None:
            st.error("No valid soil moisture data.")
            return None
        st.info(f"Soil moisture data from: {start_date.strftime('%Y-%m-%d')} to {end_date.strftime('%Y-%m-%d')}")
        return round(recent_value * 100, 2)
    except Exception as e:
        st.error(f"Error fetching soil moisture data: {str(e)}")
        return None

# Function to display soil moisture map
def display_soil_moisture_map(lat, lon, soil_moisture):
    try:
        m = folium.Map(location=[lat, lon], zoom_start=10)
        folium.Marker([lat, lon], popup=f"Soil Moisture: {soil_moisture}%", icon=folium.Icon(color='green')).add_to(m)
        folium.Circle(location=[lat, lon], radius=2000, color='blue', fill=True, popup='Measurement Area').add_to(m)
        folium_static(m)
    except Exception as e:
        st.error(f"Error displaying map: {str(e)}")

# Function to get coordinates from city name
def get_coordinates(city):
    try:
        url = f"https://nominatim.openstreetmap.org/search?city={city}&format=json"
        headers = {'User-Agent': 'AgroBloom-AI/1.0'}
        response = requests.get(url, headers=headers)
        data = response.json()
        if data:
            return float(data[0]['lat']), float(data[0]['lon'])
        return None, None
    except Exception as e:
        st.error(f"Error getting coordinates: {str(e)}")
        return None, None

# Load environment variables
load_dotenv()
api_key = os.getenv("API_KEY")
genai.configure(api_key=os.getenv("GOOGLE_API_KEY"))

# Load CSS
def local_css(file_name):
    try:
        with open(file_name, "r") as f:
            st.markdown(f'<style>{f.read()}</style>', unsafe_allow_html=True)
    except Exception as e:
        st.warning(f"Could not load CSS file {file_name}: {e}")

local_css("style.css")

# Load Lottie Animations
def load_lottieurl(url: str):
    r = requests.get(url)
    if r.status_code != 200:
        return None
    return r.json()

lottie_agri = load_lottieurl("https://assets1.lottiefiles.com/packages/lf20_ygiuluqn.json")

# -------------------- RAG Setup --------------------
# -------------------- Updated RAG Prompt Template --------------------
PROMPT_TEMPLATE = """
You are an AI-powered Smart Agriculture Assistant specializing in precision farming. Using the provided document context, answer the user's query accurately and concisely. If the context lacks sufficient information, indicate that and provide a general response based on standard agricultural knowledge.

User Query: {user_query}

Document Context: {document_context}

Answer:
"""

PDF_STORAGE_PATH = 'docs/'
os.makedirs(PDF_STORAGE_PATH, exist_ok=True)
EMBEDDING_MODEL = OllamaEmbeddings(model="deepseek-r1:1.5b")
DOCUMENT_VECTOR_DB = InMemoryVectorStore(EMBEDDING_MODEL)
LANGUAGE_MODEL = OllamaLLM(model="deepseek-r1:1.5b")

def save_uploaded_files(uploaded_files):
    saved_paths = []
    for file in uploaded_files:
        file_path = os.path.join(PDF_STORAGE_PATH, file.name)
        with open(file_path, "wb") as f:
            f.write(file.getbuffer())
        saved_paths.append(file_path)
    return saved_paths

def load_pdf_documents(file_path):
    document_loader = PDFPlumberLoader(file_path)
    return document_loader.load()

def process_pdf_batch(file_paths):
    all_chunks = []
    for i, path in enumerate(file_paths, 1):
        with st.status(tr("processing_pdf").format(current=i, total=len(file_paths))):
            try:
                docs = load_pdf_documents(path)
                chunks = chunk_documents(docs)
                all_chunks.extend(chunks)
                st.write(f"Processed: {os.path.basename(path)}")
            except Exception as e:
                st.error(f"Error processing {path}: {str(e)}")
    return all_chunks

def chunk_documents(raw_documents):
    text_processor = RecursiveCharacterTextSplitter(
        chunk_size=1000,
        chunk_overlap=200,
        add_start_index=True
    )
    return text_processor.split_documents(raw_documents)

def index_documents(document_chunks):
    DOCUMENT_VECTOR_DB.add_documents(document_chunks)

def find_related_documents(query):
    return DOCUMENT_VECTOR_DB.similarity_search(query)

def generate_answer(user_query, context_documents):
    context_text = "\n\n".join([doc.page_content for doc in context_documents])
    conversation_prompt = ChatPromptTemplate.from_template(PROMPT_TEMPLATE)
    response_chain = conversation_prompt | LANGUAGE_MODEL
    return response_chain.invoke({"user_query": user_query, "document_context": context_text})

# -------------------- FUNCTIONS --------------------
def get_weather_data(city):
    api_key = os.getenv("API_KEY")
    base_url = f"http://api.openweathermap.org/data/2.5/weather?q={city}&appid={api_key}&units=metric"
    response = requests.get(base_url)
    return response.json()

def load_data():
    try:
        soil_data = pd.read_csv("soil_analysis_data.csv")
        crop_production_data = pd.read_csv("crop_production_data.csv")
        return soil_data, crop_production_data
    except Exception as e:
        st.error(f"Error loading data: {e}")
        return None, None

def analyze_soil_health(pH, nitrogen, phosphorus, potassium, organic_matter):
    healthy = {'pH': (6.0, 7.5), 'nitrogen': (20, 50), 'phosphorus': (15, 40), 'potassium': (15, 40), 'organic_matter': (3, 6)}
    moderate = {'pH': (5.5, 6.0), 'nitrogen': (10, 20), 'phosphorus': (10, 15), 'potassium': (10, 15), 'organic_matter': (2, 3)}
    pH_status = 'Healthy' if healthy['pH'][0] <= pH <= healthy['pH'][1] else ('Moderate' if moderate['pH'][0] <= pH <= moderate['pH'][1] else 'Unhealthy')
    nitrogen_status = 'Healthy' if healthy['nitrogen'][0] <= nitrogen <= healthy['nitrogen'][1] else ('Moderate' if moderate['nitrogen'][0] <= nitrogen <= moderate['nitrogen'][1] else 'Unhealthy')
    phosphorus_status = 'Healthy' if healthy['phosphorus'][0] <= phosphorus <= healthy['phosphorus'][1] else ('Moderate' if moderate['phosphorus'][0] <= phosphorus <= moderate['phosphorus'][1] else 'Unhealthy')
    potassium_status = 'Healthy' if healthy['potassium'][0] <= potassium <= healthy['potassium'][1] else ('Moderate' if moderate['potassium'][0] <= potassium <= moderate['potassium'][1] else 'Unhealthy')
    organic_matter_status = 'Healthy' if healthy['organic_matter'][0] <= organic_matter <= healthy['organic_matter'][1] else ('Moderate' if moderate['organic_matter'][0] <= organic_matter <= moderate['organic_matter'][1] else 'Unhealthy')
    return {
        'pH': pH_status,
        'Nitrogen': nitrogen_status,
        'Phosphorus': phosphorus_status,
        'Potassium': potassium_status,
        'Organic Matter': organic_matter_status
    }


# Load datasets
@st.cache_data
def load_data():
    try:
        soil_data = pd.read_csv("soil_analysis_data.csv")
        crop_data = pd.read_csv("crop_production_data.csv")
        return soil_data, crop_data
    except Exception as e:
        st.error(f"Error loading data: {e}")
        return None, None
    


def get_historical_weather_data():
    return pd.DataFrame({
        'temperature': [22, 24, 20, 23, 25],
        'humidity': [60, 65, 70, 55, 50],
        'precipitation': [5, 0, 10, 0, 0],
        'soil_moisture': [30, 28, 35, 33, 30]
    })

def train_irrigation_model():
    data = get_historical_weather_data()
    X = data[['temperature', 'humidity', 'precipitation']]
    y = data['soil_moisture']
    model = RandomForestRegressor(n_estimators=100, random_state=42)
    model.fit(X, y)
    joblib.dump(model, "irrigation_model.pkl")
    return model

def load_irrigation_model():
    try:
        model = joblib.load("irrigation_model.pkl")
        return model
    except FileNotFoundError:
        st.write("No trained irrigation model found.")
        return None

def irrigation_management(weather_data, soil_moisture):
    model = load_irrigation_model()
    if model:
        temp = weather_data['main']['temp']
        humidity = weather_data['main']['humidity']
        precipitation = weather_data.get('rain', {}).get('1h', 0)
        prediction = model.predict([[temp, humidity, precipitation]])
        predicted_soil_moisture = prediction[0]
        st.write(f"Current Soil Moisture: {soil_moisture}%")
        if soil_moisture < predicted_soil_moisture:
            st.warning("Irrigation needed to reach optimal soil moisture levels.")
        else:
            st.success("Soil moisture is sufficient; no additional irrigation required.")
    else:
        st.error("Unable to perform irrigation management without a trained model.")

def speech_to_text():
    """
    Convert speech to text using the microphone.
    """
    recognizer = sr.Recognizer()
    try:
        with sr.Microphone() as source:
            st.write("Listening... Speak now!")
            recognizer.adjust_for_ambient_noise(source)  # Adjust for ambient noise
            audio = recognizer.listen(source, timeout=5)  # Listen for 5 seconds
            try:
                text = recognizer.recognize_google(audio)
                return text
            except sr.UnknownValueError:
                st.warning("Sorry, I could not understand the audio.")
            except sr.RequestError as e:
                st.error(f"Could not request results from Google Speech Recognition service; {str(e)}")
    except Exception as e:
        st.error(f"Error in speech-to-text conversion: {str(e)}")
    return None

# -------------------- Main App --------------------
def main():
    global current_language

    # Language selection
    language = st.sidebar.selectbox(tr("select_language"), ["English", "‡§π‡§ø‡§Ç‡§¶‡•Ä", "‡§Æ‡§∞‡§æ‡§†‡•Ä"])
    if language == "English":
        current_language = "en"
    elif language == "‡§π‡§ø‡§Ç‡§¶‡•Ä":
        current_language = "hi"
    elif language == "‡§Æ‡§∞‡§æ‡§†‡•Ä":
        current_language = "mr"

    # Sidebar with RAG option added
    st.sidebar.title(tr("sidebar_title"))
    menu = [
        tr("home"),
        tr("irrigation_management"),
        tr("soil_health_analysis"),
        tr("disease_detection"),
        tr("ai_assistant")
    ]
    choice = st.sidebar.radio(tr("navigation"), menu)

    # Home Page
    if choice == tr("home"):
        st.markdown(f"<h1 style='text-align: center; color: #2E8B57;'>{tr('home_title')}</h1>", unsafe_allow_html=True)
        st.markdown("---")
        col1, col2 = st.columns([2, 1])
        with col1:
            st.markdown(f"<div style='text-align: justify; font-size: 20px;'>{tr('welcome_message')}</div>", unsafe_allow_html=True)
            st.markdown("<br>", unsafe_allow_html=True)
            colored_header(label=tr("weather_report"), description=tr("smart_weather_desc"), color_name="green-70")
            city = st.text_input(f"üìç {tr('enter_location')}", "London")
            if st.button(tr("get_weather_analysis"), use_container_width=True):
                with st.spinner(tr("fetching_weather_data")):
                    weather_data = get_weather_data(city)
                    if weather_data and weather_data.get("main"):
                        st.subheader(f"{tr('weather_report')} {city}")
                        weather_cols = st.columns(4)
                        weather_cols[0].metric(tr("temperature"), f"{weather_data['main']['temp']}¬∞C", help="Optimal range for most crops: 15-30¬∞C")
                        weather_cols[1].metric(tr("humidity"), f"{weather_data['main']['humidity']}%", "Ideal range: 40-80%")
                        weather_cols[2].metric(tr("precipitation"), f"{weather_data.get('rain', {}).get('1h', 0)}mm", "Next 3 hours")
                        weather_cols[3].metric(tr("wind_speed"), f"{weather_data['wind']['speed']} m/s", "Wind direction")
                        style_metric_cards()
                        temp = weather_data['main']['temp']
                        if temp < 10:
                            advisory = tr("frost_alert")
                        elif 10 <= temp < 20:
                            advisory = tr("cool_weather")
                        elif 20 <= temp < 30:
                            advisory = tr("optimal_conditions")
                        else:
                            advisory = tr("heat_stress")
                        st.markdown(f"""
                            <div class="advisory-box">
                                <h3>üå± {tr('farming_advisory')}</h3>
                                <p>{advisory}</p>
                            </div>
                        """, unsafe_allow_html=True)
                    else:
                        st.error(tr("failed_to_retrieve_weather_data"))
            features = [
                {"icon": "üå§", "title": tr("smart_weather_insights"), "desc": tr("smart_weather_desc")},
                {"icon": "üíß", "title": tr("ai_irrigation_system"), "desc": tr("ai_irrigation_desc")},
                {"icon": "üìä", "title": tr("soil_health_dashboard"), "desc": tr("soil_health_desc")},
                {"icon": "üåø", "title": tr("disease_detection_title"), "desc": tr("disease_detection_desc")}
            ]
            for feat in features:
                st.markdown(f"""
                    <div class="feature-card">
                        <span class="feature-icon">{feat['icon']}</span>
                        <h3 class="feature-title">{feat['title']}</h3>
                        <p class="feature-desc">{feat['desc']}</p>
                    </div>
                """, unsafe_allow_html=True)
        with col2:
            st_lottie(lottie_agri, height=400, key="agri")
        st.markdown("---")
        st.markdown(f"""
            <div style='text-align: center; padding: 20px;'>
                <h3>üåç {tr('join_revolution')}</h3>
                <p>{tr('start_journey')}</p>
            </div>
        """, unsafe_allow_html=True)


    # Irrigation Management
    elif choice == tr("irrigation_management"):
        colored_header(label=tr("smart_irrigation_system"), description=tr("irrigation_desc"), color_name="blue-70")
        suggested_regions = {
            "India": [
                "Punjab, India",
                "Haryana, India",
                "Uttar Pradesh, India",
                "Bihar, India",
                "West Bengal, India",
                "Maharashtra, India",
                "Karnataka, India",
                "Tamil Nadu, India",
                "Andhra Pradesh, India",
                "Madhya Pradesh, India",
                "Gujarat, India",
                "Rajasthan, India"
            ]
        }
        col1, col2 = st.columns([1, 2])
        with col1:
            st.subheader(tr("field_parameters"))
            region_category = st.selectbox(tr("select_region_category"), ["India"])
            city = st.selectbox(f"üìç {tr('select_location')}", suggested_regions[region_category])
            use_custom_location = st.checkbox(tr("use_custom_location"))
            if use_custom_location:
                city = st.text_input(tr("enter_custom_location"))
            crop_type = st.selectbox(tr("crop_type"), ["Wheat", "Cotton", "Rice", "Sugarcane"])
            st.caption(tr("optimal_moisture_tip"))
            if st.button(tr("calculate_irrigation"), use_container_width=True):
                with st.spinner(tr("analyzing_field_conditions")):
                    lat, lon = get_coordinates(city)
                    if lat and lon:
                        soil_moisture = get_soil_moisture(lat, lon)
                        if soil_moisture is not None:
                            weather_data = get_weather_data(city)
                            if weather_data and weather_data.get("main"):
                                with col2:
                                    st.subheader(tr("irrigation_plan"))
                                    st.write(f"### üó∫ {tr('soil_moisture_map')}")
                                    display_soil_moisture_map(lat, lon, soil_moisture)
                                    st.write(f"### üìä {tr('current_conditions')}")
                                    cols = st.columns(3)
                                    cols[0].metric(tr("soil_moisture"), f"{soil_moisture}%", delta="Real-time data", help="Real-time soil moisture from satellite data")
                                    cols[1].metric(tr("temperature"), f"{weather_data['main']['temp']}¬∞C")
                                    cols[2].metric(tr("humidity"), f"{weather_data['main']['humidity']}%")
                                    st.write(f"### üíß {tr('irrigation_analysis')}")
                                    irrigation_management(weather_data, soil_moisture)
                                    st.markdown(f"""
                                        <div style="margin: 20px 0;">
                                            <h4>{tr('soil_moisture_level')}</h4>
                                            <div class="moisture-gauge" style="
                                                background: #f0f2f6;
                                                border-radius: 10px;
                                                height: 30px;
                                                width: 100%;
                                                overflow: hidden;
                                            ">
                                                <div style="
                                                    background: linear-gradient(90deg, #2E8B57, #3CB371);
                                                    width: {soil_moisture}%;
                                                    height: 100%;
                                                    display: flex;
                                                    align-items: center;
                                                    justify-content: center;
                                                    color: white;
                                                    transition: width 0.5s ease-in-out;
                                                ">
                                                    {soil_moisture}%
                                                </div>
                                            </div>
                                        </div>
                                    """, unsafe_allow_html=True)
                                    optimal_moisture = {"Wheat": (30, 50), "Cotton": (35, 55), "Rice": (60, 90), "Sugarcane": (40, 60)}
                                    crop_range = optimal_moisture[crop_type]
                                    st.write(f"### üåæ {tr('crop_specific_analysis')} {crop_type}")
                                    st.write(f"{tr('optimal_soil_moisture_range')}: {crop_range[0]}% - {crop_range[1]}%")
                                    if soil_moisture < crop_range[0]:
                                        st.warning(tr("below_optimal").format(crop_type=crop_type))
                                    elif soil_moisture > crop_range[1]:
                                        st.warning(tr("above_optimal").format(crop_type=crop_type))
                                    else:
                                        st.success(tr("within_optimal").format(crop_type=crop_type))
    # Soil Health Analysis
    elif choice == tr("soil_health_analysis"):
        colored_header(label=tr("soil_health_dashboard"), description=tr("soil_health_desc"), color_name="orange-70")
        with st.expander(f"üîç {tr('how_to_use')}"):
            st.markdown(f"""
                1. Soil test results are automatically loaded from the dataset.<br>
                2. Use the navigation buttons to view each record.<br>
                3. Click 'Analyze Soil Health' to process the currently displayed record.
            """, unsafe_allow_html=True)
        col1, col2 = st.columns([1, 2])
        try:
            soil_data = pd.read_csv("soil_analysis_data.csv")
        except Exception as e:
            st.error(f"Error loading soil data: {e}")
            soil_data = None

        if soil_data is not None and not soil_data.empty:
            if "soil_index" not in st.session_state:
                st.session_state.soil_index = 0
            current_index = st.session_state.soil_index
            st.write(f"Record {current_index + 1} of {len(soil_data)}")
            record = soil_data.iloc[current_index]
            st.dataframe(record.to_frame().T)
            try:
                pH = float(record["pH Level"])
                nitrogen = float(record["Nitrogen Content (kg/ha)"])
                phosphorus = float(record["Phosphorus Content (kg/ha)"])
                potassium = float(record["Potassium Content (kg/ha)"])
                organic_matter = float(record["Organic Matter (%)"])
            except Exception as e:
                st.error(f"Error extracting soil parameters: {e}")
                pH, nitrogen, phosphorus, potassium, organic_matter = None, None, None, None, None

            col_nav1, col_nav2, col_nav3 = st.columns(3)
            with col_nav1:
                if st.button("Previous Sample", key="prev_sample"):
                    if st.session_state.soil_index > 0:
                        st.session_state.soil_index -= 1
                        if "analysis_result" in st.session_state:
                            del st.session_state.analysis_result
                    else:
                        st.warning("Already at the first sample.")
            with col_nav3:
                if st.button("Next Sample", key="next_sample"):
                    if st.session_state.soil_index < len(soil_data) - 1:
                        st.session_state.soil_index += 1
                        if "analysis_result" in st.session_state:
                            del st.session_state.analysis_result
                    else:
                        st.warning("Already at the last sample.")
            with col1:
                st.markdown("### Soil Parameters from Dataset")
                st.write(f"pH: {pH}")
                st.write(f"Nitrogen: {nitrogen}")
                st.write(f"Phosphorus: {phosphorus}")
                st.write(f"Potassium: {potassium}")
                st.write(f"Organic Matter: {organic_matter}")
            if st.button("Analyze Soil Health", key="analyze_soil_button"):
                if None not in (pH, nitrogen, phosphorus, potassium, organic_matter):
                    with st.spinner(tr("analyzing_soil_composition")):
                        analysis = analyze_soil_health(pH, nitrogen, phosphorus, potassium, organic_matter)
                        st.session_state.analysis_result = analysis
                        st.session_state.analysis_index = st.session_state.soil_index
                else:
                    st.error("Unable to extract soil parameters from the current record.")
            if "analysis_result" in st.session_state and st.session_state.get("analysis_index") == current_index:
                with col2:
                    st.subheader(tr("analysis_results"))
                    result = st.session_state.analysis_result
                    st.markdown(f"""
                        <div class="gauge-container">
                            <p><strong>pH:</strong> {result['pH']}</p>
                            <p><strong>{tr('nitrogen')}:</strong> {result['Nitrogen']}</p>
                            <p><strong>{tr('phosphorus')}:</strong> {result['Phosphorus']}</p>
                            <p><strong>{tr('potassium')}:</strong> {result['Potassium']}</p>
                            <p><strong>{tr('organic_matter')}:</strong> {result['Organic Matter']}</p>
                        </div>
                    """, unsafe_allow_html=True)
                    st.markdown(f"""
                        <div class="recommendation-box">
                            <h3>{tr('recommended_actions')}</h3>
                            <ul>
                                <li>{tr('apply_organic_compost')}</li>
                                <li>{tr('ideal_soil_ph')}</li>
                                <li>{tr('ideal_nitrogen')}</li>
                                <li>{tr('ideal_phosphorus')}</li>
                                <li>{tr('ideal_potassium')}</li>
                                <li>{tr('retest_soil')}</li>
                            </ul>
                        </div>
                    """, unsafe_allow_html=True)
                    if st.button("Clear Analysis", key="clear_analysis"):
                        del st.session_state.analysis_result
                        if "analysis_index" in st.session_state:
                            del st.session_state.analysis_index
        else:
            st.error("Soil data is empty or could not be loaded.")
    
    elif choice == tr("disease_detection"):
        colored_header(label=tr("disease_detection_title"), description=tr("disease_detection_desc"), color_name="red-70")
        with st.expander(f"üîç {tr('how_to_use')}"):
            st.markdown(f"""
                1. {tr('upload_plant_image_desc')}<br>
                2. {tr('click_analyze_disease')}<br>
                3. {tr('receive_disease_recommendations')}
            """, unsafe_allow_html=True)
        col1, col2 = st.columns([1, 2])
        with col1:
            uploaded_file = st.file_uploader(tr("upload_plant_image"), type=["jpg", "png"], key="plant_image_uploader")
            if uploaded_file:
                try:
                    image = Image.open(BytesIO(uploaded_file.read()))
                    st.image(image, caption=tr("uploaded_image"), use_column_width=True)
                    if st.button(tr("analyze_disease"), use_container_width=True):
                        with st.spinner(tr("analyzing_disease")):
                            disease_info = analyze_plant_disease(image)
                            with col2:
                                st.subheader(tr("disease_detection_results"))
                                st.write(disease_info)
                                st.markdown(f"""
                                    <div class="recommendation-box">
                                        <h3>{tr('recommended_actions')}</h3>
                                        <ul>
                                            <li>{tr('consult_expert')}</li>
                                            <li>{tr('apply_treatment')}</li>
                                            <li>{tr('monitor_health')}</li>
                                        </ul>
                                    </div>
                                """, unsafe_allow_html=True)
                except UnidentifiedImageError:
                    st.error(tr("invalid_image_error"))
                except Exception as e:
                    st.error(f"{tr('error_occurred')}: {str(e)}")

    elif choice == tr("ai_assistant"):
        colored_header(label=tr("ai_assistant"), description=tr("rag_description"), color_name="green-70")
        st.write(tr("rag_upload_help"))

        # File uploader for PDFs
        uploaded_files = st.file_uploader(
            tr("pdf_upload_label"),
            type=["pdf"],
            accept_multiple_files=True,
            help=tr("rag_upload_help"),
            key="pdf_uploader"  # Unique key for this file_uploader
        )

        if uploaded_files:
            if len(uploaded_files) > 4:
                st.warning(tr("max_files_warning"))
                uploaded_files = uploaded_files[:4]
            with st.spinner("Processing uploaded documents..."):
                file_paths = save_uploaded_files(uploaded_files)
                document_chunks = process_pdf_batch(file_paths)
                if document_chunks:
                    index_documents(document_chunks)
                    st.success(tr("doc_processed_success"))
                else:
                    st.error(tr("processing_error"))

        # Query Input with Speech-to-Text
        st.write("### Ask Your Question")
        col1, col2 = st.columns([4, 1])
        with col1:
            user_query = st.text_input(tr("ask_agriculture_question"), "", key="text_query")
        with col2:
            if st.button("üé§", key="mic_button", help="Click to speak your query"):
                with st.spinner("Listening..."):
                    spoken_query = speech_to_text()
                    if spoken_query:
                        st.session_state.user_query = spoken_query  # Store the spoken query in session

        # Use the spoken query if available
        if "user_query" in st.session_state and st.session_state.user_query:
            user_query = st.session_state.user_query
            st.text_area("Your Spoken Query", value=user_query, key="spoken_query_display")

        if user_query:
            with st.spinner("Generating response..."):
                try:
                    related_docs = find_related_documents(user_query)
                    response = generate_answer(user_query, related_docs)
                    st.write("**Response:**")
                    st.write(response)

                    # Text-to-Speech for the Response
                    if st.button("üîä Convert Response to Speech", key="tts_button"):
                        text_to_speech(response)
                except Exception as e:
                    st.error(f"{tr('response_error')}: {str(e)}")

if __name__ == "__main__":
    main()